! Module file: exportmmcifstruct
!
! CNS module
! **********
!
! Author:    John Westbrook  
!            Nucleic Acid Database Project
!            Department of Chemistry
!            Rutgers University 
!            jwest@ndb.rutgers.edu
!
! Updated:   Aug 17, 1998
!
! Function:  Produces a partial mmCIF file.
!
!            This module populates the mmCIF categories describing
!            the refined structure.
!
! copyright Yale University
!

module { exportmmcifstruct }
(
 &entry_id="cnsmmcif";   
 &title="My very interesting structure";
 &a=1;
 &b=1;
 &c=1;
 &alpha=90;
 &beta=90;
 &gamma=90;

 &sgparam;

 &all_select=( known and not hydr ); {select all atoms used} 
 &polymer_select=( none );           {select all polymer atoms}
 &nonpolymer_select=( none);         {select all nonpolymer atoms less solvent}
 &water_select=( none);              {select all water atoms}

 &sel_alt_conf=(not all);

 &num_asym=1;
 &asym_id= (known and not hydrogen);  {place-holders for mmCIF
                                       asym_id definitions}

 &num_entity=1;
 &entity_id=(known and not hydrogen); {place-holders for mmCIF 
                                       entity_id definitions}

 &list="deposit.mmcif"; { output file name}
)

checkversion 1.3

set message ? end
evaluate ($message_old=$result)
set echo ? end
evaluate ($echo_old=$result)
if ( $log_level = verbose ) then
  set echo=on message=normal end
else
  set echo=off message=off end
end if

evaluate ($display=&list) 
set display=$display end

display # 
display # mmCIF generated by CNS module exportmmcifstruct (V $CNS_VERSION) 
display #
evaluate ($entry_id=&entry_id)
display data_$entry_id
display #
display _entry.id                         $entry_id
display #
display _struct.entry_id                  $entry_id
display _struct.title 
display ;
display &title
display ;
display #
display _computing.entry_id               $entry_id
evaluate ($pvers="'CNS " + $CNS_VERSION + "'")
display _computing.structure_refinement   $pvers
display #
display #
display _software.name                 'Crystallography & NMR System'
display _software.version              $CNS_VERSION
display _software.date                 1998
display _software.type                 package
display _software.contact_author       'Axel T. Brunger'
display _software.contact_author_email 'brunger@stanford.edu'
display _software.location             .
display _software.classification       refinement
display _software.language             Fortran
display _software.citation_id          1
display #
display #
display _citation.id        1
display _citation.title    'Crystallography & NMR System'
display _citation.year      1998
display _citation.details  'Acta Cryst. D 54, 905-921'
display #
display #
display loop_
display _citation_author.citation_id
display _citation_author.ordinal
display _citation_author.name
display   1   1   'Brunger, A.T.'
display   1   2   'Adams, P.D.' 
display   1   3   'Clore, G.M.'
display   1   4   'Delano, W.L.'
display   1   5   'Gros, P.'
display   1   6   'Grosse-Kunstleve, R.'
display   1   7   'Jiang, J.-S.'
display   1   8   'Kuszewski, J.'
display   1   9   'Nilges, M.'
display   1   10  'Pannu, N.S.'
display   1   11  'Read, R.J.'
display   1   12  'Rice, L.M.'
display   1   13  'Simonson, T.'
display   1   14  'Warren, G.'


{* ======================================================== *}  
{* Number of atoms used in refinement                       *}
{* The category and selection are defined as the following  *}

{* "$NATOM"             all non-hydrogen atoms      *}
{* "$NATOM_POLY"        protein atoms                *}
{* "$NATOM_WAT"         solvent atoms               *}
{* "$NATOM_NONPOLY"     ligand/heterogen/ions       *}

   show sum ( 1 ) ( &all_select )
   evaluate ( $NATOM=$result )

   {* polymer atoms *}
   show sum ( 1 ) ( &polymer_select )
   evaluate ( $NATOM_POLY=$result )

   {* solvent atoms *}
   show sum ( 1 ) ( &water_select )
   evaluate ( $NATOM_WAT=$result )

   {* nonpolymer atoms or ions *}
   show sum ( 1 ) ( &nonpolymer_select )
   evaluate ( $NATOM_NONPOLY=$result )

{ *** Project the ENTITY TYPE into an enumerated atom array.  ***}

do (store1=0) (all)
do (store1=1) (&polymer_select)
do (store1=2) (&nonpolymer_select)
do (store1=3) (&water_select)

display #
display #
display loop_
display _entity.id
display _entity.type

evaluate ($eid=0)  ! entity id is a 1 based index.
while ($eid < &num_entity) loop entity
   evaluate ($eid = $eid + 1)
   ident (store2) ((attr &entity_id = $eid) and (attr store1 = 1))
   show sum ( store2 ) ( store2 ) 
   if ($select > 0) then
      display   $eid[i4]   'polymer'
   end if

   ident (store2) ((attr &entity_id = $eid) and (attr store1 = 2))
   show sum ( store2 ) ( store2 ) 
   if ($select > 0) then
      display   $eid[i4]   'non-polymer'
   end if

   ident (store2) ((attr &entity_id = $eid) and (attr store1 = 3))
   show sum ( store2 ) ( store2 ) 
   if ($select > 0) then
      display   $eid[i4]   'water'
   end if
end loop entity

{ ***  Capture the sequence numbering within each polymeric entity *** }
{ ***  and store this in <store5>                                  *** }

do (fbet=-1) ( all )
evaluate ($eid=0)  ! entity id is a 1 based index.
while ($eid < &num_entity) loop 1polyentity
   evaluate ($eid = $eid + 1)
   ident (store2) ((attr &entity_id = $eid) and (attr store1 = 1))
   show sum ( store2 ) ( store2 )
   if ($select > 0) then
      evaluate ($aid=0)
      evaluate ($ncopies=0)
      while ($aid < &num_asym) loop 1asym
           evaluate ($aid=$aid+1)
           ident (store5) ((store2) and (attr &asym_id = $aid))
           show sum (store5) (store5)
           if ($select > 0) then
               evaluate ($ncopies=$ncopies+1)
               evaluate ($ires=0)
               for $atom_id in id ( store5 and tag ) loop 1residues
                   show elem ( resname ) ( id $atom_id )
                   evaluate ($ires=$ires+1)
                   do (fbet=$ires) (byres (id $atom_id))
               end loop 1residues
           end if
      end loop 1asym
   end if
end loop 1polyentity

display #
display #
display loop_
display _struct_asym.id
display _struct_asym.entity_id

evaluate ($aid=0)
while ($aid < &num_asym) loop asymunit
   evaluate ($aid = $aid + 1)
   ident (store2) (attr &asym_id = $aid)  
   show sum ( store2 ) ( store2 ) 
   if ($select > 0) then
      evaluate ($eid=0)
      while ($eid < &num_entity) loop entities
         evaluate ($eid = $eid + 1)
         ident (store5) ((store2) and (attr &entity_id = $eid))
         show sum ( store5 ) ( store5 ) 	
         if ($select > 0) then
            display $aid[i4]  $eid[i4]
         end if 
      end loop entities
   end if 
end loop asymunit



{* ================================================ *}
{*    Disulfide bonds in STRUCT_CONN category       *}

 display #
 display #
 display loop_
 display _struct_conn.id
 display _struct_conn.conn_type_id
 display _struct_conn.pntr1_label_comp_id
 display _struct_conn.pntr1_label_seq_id
 display _struct_conn.pntr1_label_asym_id
 display _struct_conn.pntr1_label_atom_id
 display _struct_conn.pntr1_label_alt_id
 display _struct_conn.pntr2_label_comp_id
 display _struct_conn.pntr2_label_seq_id
 display _struct_conn.pntr2_label_asym_id
 display _struct_conn.pntr2_label_atom_id
 display _struct_conn.pntr2_label_alt_id

 ident (store2) ( name SG and resname CYS and &all_select)
 evaluate ($NSSBND=0)
 for $i in id ( store2 ) loop i
   for $j in id ( store2 ) loop j 
     if ($i < $j) then
       pick bond (id $i) (id $j) geometry
       evaluate ($dist=$result)
       if ($dist < 2.3) then
          evaluate ($NSSBND=$NSSBND+1)
          show elem (fbet) ( id $i )
          evaluate ($iseqid=$result)
          show elem (fbet) ( id $j )
          evaluate ($jseqid=$result)

          show elem (&asym_id) ( id $i )
          evaluate ($iasymid=$result)
          show elem (&asym_id) ( id $j )
          evaluate ($jasymid=$result)

          show elem (&sel_alt_conf) ( id $i )
          evaluate ($ialtid=$result)
          if ($ialtid = 0) then 
              evaluate ($ialtid = ".")
          end if 
          show elem (&sel_alt_conf) ( id $j )
          evaluate ($jaltid=$result)
          if ($jaltid = 0) then 
              evaluate ($jaltid = ".")
          end if 

          show elem (name) ( id $i )
          evaluate ($inam="'" + $result + "'")
          show elem (name) ( id $j )
          evaluate ($jnam="'" + $result + "'")

          display $NSSBND[i3]  'disulf' CYS   $iseqid[i4] $iasymid[i4] \
$inam[a4] $ialtid CYS   $jseqid[i4] $jasymid[i4] $jnam[a4] $jaltid
       end if
     end if
   end loop j
 end loop i

 if ($NSSBND > 0)  then 
    display #
    display _struct_conn_type.id          'disulf'
    display _struct_conn_type.criteria    'CYS to CYS distance < 2.3 Angstroms'
 else
    display ? ? ? ? ? ? ? ? ? ? 
 end if

{* ================================================ *}
{*      CELL and SYMMETRY categories                *}

 evaluate ($sg=&sg) 

 xray
      set display=OUTPUT end

      {* get the name of space group *}
      @@CNS_XTALMODULE:pdbgetsgname
         (   
           sg=&sgparam.sg_number;     { space group number  }
           sgname=$sg_name;           { return PDB's s.g. name    }
          )

      set display=$display end


      display #
      display _cell.entry_id               $entry_id
      display _cell.length_a             $XRCELL_1[f8.3]
      display _cell.length_b             $XRCELL_2[f8.3]
      display _cell.length_c             $XRCELL_3[f8.3]
      display _cell.angle_alpha           $XRCELL_4[f6.2]
      display _cell.angle_beta            $XRCELL_5[f6.2]
      display _cell.angle_gamma           $XRCELL_6[f6.2]
      display #
      display #
      display _symmetry.entry_id               $entry_id
      evaluate($tstr3="'"+$sg_name+"'")
      display _symmetry.space_group_name_H-M   $tstr3

      {* ================================================ *}
      {*            ATOM_SITES category                   *}

      evaluate ($zero=0.0)
      evaluate ($one=1.0)
      display #
      display #
      display _atom_sites.entry_id                      $entry_id
      display _atom_sites.cartn_transf_matrix[1][1]     $one[f9.6]
      display _atom_sites.cartn_transf_matrix[1][2]     $zero[f9.6]
      display _atom_sites.cartn_transf_matrix[1][3]     $zero[f9.6]  
      display _atom_sites.cartn_transf_matrix[2][1]     $zero[f9.6]
      display _atom_sites.cartn_transf_matrix[2][2]     $one[f9.6]
      display _atom_sites.cartn_transf_matrix[2][3]     $zero[f9.6]
      display _atom_sites.cartn_transf_matrix[3][1]     $zero[f9.6]
      display _atom_sites.cartn_transf_matrix[3][2]     $zero[f9.6]
      display _atom_sites.cartn_transf_matrix[3][3]     $one[f9.6]
      display _atom_sites.cartn_transf_vector[1]        $zero[f9.6]
      display _atom_sites.cartn_transf_vector[2]        $zero[f9.6]
      display _atom_sites.cartn_transf_vector[3]        $zero[f9.6]

      display _atom_sites.fract_transf_matrix[1][1]     $XRTR_1_1[f9.6]
      display _atom_sites.fract_transf_matrix[1][2]     $XRTR_1_2[f9.6]
      display _atom_sites.fract_transf_matrix[1][3]     $XRTR_1_3[f9.6]
      display _atom_sites.fract_transf_matrix[2][1]     $XRTR_2_1[f9.6]
      display _atom_sites.fract_transf_matrix[2][2]     $XRTR_2_2[f9.6]
      display _atom_sites.fract_transf_matrix[2][3]     $XRTR_2_3[f9.6]
      display _atom_sites.fract_transf_matrix[3][1]     $XRTR_3_1[f9.6]
      display _atom_sites.fract_transf_matrix[3][2]     $XRTR_3_2[f9.6]
      display _atom_sites.fract_transf_matrix[3][3]     $XRTR_3_3[f9.6]
      display _atom_sites.fract_transf_vector[1]        $zero[f9.6]
      display _atom_sites.fract_transf_vector[2]        $zero[f9.6]
      display _atom_sites.fract_transf_vector[3]        $zero[f9.6]
  end

set message=on end
set echo=on end

{* ============================================== *}
{* Produce NCS the generator  matrices            *}
  ncs strict
  ?
  if ($ncs > 1) then
     evaluate ($k=0)
     while ($k < $ncs) loop k1
       evaluate ($k=$k+1)
       evaluate ($i=1)
       while ($i < 4) loop i1
         evaluate ($j=0)
         while ($j < 4) loop j
           evaluate ($j=$j+1)
           evaluate ($op_$i_$j_$k = $ncsop_$k_$i_$j)
         end loop j
         evaluate ($i=$i+1)
       end loop i1
     end loop k1

  {* "$op_$i_$j_$k" is rotation matrix for "$j=1,2,3"   *}
  {*                is translation vector when "$j=4"   *}
     display #	
     display #	
     display #	*** Only the operations which generate the NCS
     display #	    related molecules are specified here... 
     display #	
     display #	    The groups of equivalent atoms must be 
     display #      entered manually at this time.
     display #	
     display loop_
     display _struct_ncs_oper.id             
     display _struct_ncs_oper.code
     display _struct_ncs_oper.matrix[1][1]
     display _struct_ncs_oper.matrix[1][2]
     display _struct_ncs_oper.matrix[1][3]
     display _struct_ncs_oper.matrix[2][1]
     display _struct_ncs_oper.matrix[2][2]
     display _struct_ncs_oper.matrix[2][3]
     display _struct_ncs_oper.matrix[3][1]
     display _struct_ncs_oper.matrix[3][2]
     display _struct_ncs_oper.matrix[3][3]
     display _struct_ncs_oper.vector[1]
     display _struct_ncs_oper.vector[2]
     display _struct_ncs_oper.vector[3]

     evaluate ($k=0)
     while ($k < $ncs) loop kk1
        evaluate ($k=$k+1)
        display  $k[i3] generate
        display  $op_1_1_$k[f9.6] $op_1_2_$k[f9.6]  $op_1_3_$k[f9.6]  
        display  $op_2_1_$k[f9.6] $op_2_2_$k[f9.6]  $op_2_3_$k[f9.6]  
        display  $op_3_1_$k[f9.6] $op_3_2_$k[f9.6]  $op_3_3_$k[f9.6] 
        display  $op_1_4_$k[f9.5] $op_2_4_$k[f9.5]  $op_3_4_$k[f9.5]
     end loop kk1
   end if    
  end

{* ================================================ *}
{*         Produce ATOM_SITE category               *}

set message=off end
set echo=off end

display #
display #
display loop_
display _atom_site.id
display _atom_site.cns_atom_id
display _atom_site.atom_type_symbol
display _atom_site.label_atom_id
display _atom_site.label_comp_id
display _atom_site.label_seq_id
display _atom_site.label_asym_id
display _atom_site.label_entity_id
display _atom_site.auth_seq_id
display _atom_site.label_alt_id
display _atom_site.Cartn_x
display _atom_site.Cartn_y
display _atom_site.Cartn_z
display _atom_site.occupancy
display _atom_site.B_iso_or_equiv

evaluate($ai=0) ! atom_id is just a running index.

for $i in id ( &all_select) loop 1atom

    evaluate($ai=$ai+1)

    show elem (chemical) ( id $i )
    evaluate ($cns_type=$result)

    show elem (iupac) ( id $i )
    evaluate ($atomidq="'" + $result + "'")

    show elem (resname) ( id $i )
    evaluate ($compid=$result)

    show elem (&asym_id) ( id $i )
    evaluate ($asymid=$result)

    show elem (fbet) ( id $i )
    evaluate ($seqid=$result)

    show elem (&entity_id) ( id $i )
    evaluate ($entityid=$result)

    show elem (&sel_alt_conf) ( id $i )
    evaluate ($altid=$result)
    if ($altid = 0) then 
       evaluate ($altid = ".")
    end if 

    show elem (x) ( id $i )
    evaluate ($x=$result)

    show elem (y) ( id $i )
    evaluate ($y=$result)

    show elem (z) ( id $i )
    evaluate ($z=$result)     

    show elem (q) ( id $i )
    evaluate ($occ=$result)     

    show elem (b) ( id $i )
    evaluate ($biso=$result)     

    show elem (resi) ( id $i )
    evaluate ($authseqid="'" + $result + "'")

    evaluate ($dot=".")
   @CNS_XTALMODULE:getatomtype
     (   
        atomname=$cns_type;
        atomtype=$at_type;
        mess=off;
     )
    if ($seqid < 0) then 
      display  $ai[i5] $i[i5] $at_type[a4] $atomidq[a6] $compid[a4] \
$dot[a5]  $asymid[i4] $entityid[i4] $authseqid[a6] $altid 
    else 
      display  $ai[i5] $i[i5] $at_type[a4] $atomidq[a6] $compid[a4] \
$seqid[i5] $asymid[i4] $entityid[i4] $authseqid[a6] $altid 
    end if

    display        $x[f9.3] $y[f9.3] $z[f9.3] $occ[f5.2] $biso[f8.2]

 
end loop 1atom

set display=$display end   

set message=$message_old echo=$echo_old end
