          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3
           Status: General release
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: lewis4-r710-login-node223 (x86_64/Linux,64-bit)
                               with 16 threads
           Program started by: oeow39
           Program started at: 16:08:11 on 05-Jul-2018
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>remarks  TSMAP.INP 
 CNSsolve>remarks  tests fmap, tsmap and psearch commands in XRAY 
 CNSsolve>remarks  By R.W.Grosse-Kunstleve 
 CNSsolve> 
 CNSsolve>{* Generate a two-atom dummy structure 
 CNSsolve> *} 
 CNSsolve>topology 
 RTFRDR>  residue SI 
 RESIDUE>    atom SI mass=14 charge=0 {chemical}type="SI+4" end 
 RESIDUE>  end 
 RTFRDR>  residue O 
 RESIDUE>    atom O  mass=8  charge=0 {chemical}type="O-1"  end 
 RESIDUE>  end 
 RTFRDR>end 
 CNSsolve> 
 CNSsolve>segment 
 SEGMENT>  name = QZ 
 SEGMENT>  molecule {res}name=SI number=1 end 
 SEGMENT>  molecule {res}name=O  number=1 end 
 SEGMENT>end 
 Status of internal molecular topology database:
 -> NATOM=          2(MAXA=     1000000)  NBOND=          0(MAXB=     1000000)
 -> NTHETA=         0(MAXT=     2000000)  NGRP=           2(MAXGRP=   1000000)
 -> NPHI=           0(MAXP=     2000000)  NIMPHI=         0(MAXIMP=   1000000)
 -> NNB=            0(MAXNB=    1000000) 
 CNSsolve> 
 CNSsolve>do (name="SI1") (resid=1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>do (name="O1")  (resid=2) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>eval($iloop=0) 
 EVALUATE: symbol $ILOOP set to    0.00000     (real)
 CNSsolve>eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 CNSsolve>eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 CNSsolve>eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 CNSsolve>eval($fcx=fcalcx) 
 Assuming literal string "FCALCX"
 EVALUATE: symbol $FCX set to "FCALCX" (string)
 CNSsolve> 
 CNSsolve>{* loop over some space groups 
 CNSsolve>     anomalous = true or false 
 CNSsolve>       partial = true or false 
 CNSsolve>         special = true or false 
 CNSsolve> *} 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "P1" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($fcx=fcalc) 
 Assuming literal string "FCALC"
 EVALUATE: symbol $FCX set to "FCALC" (string)
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P1 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha = 100) 
 EVALUATE: symbol $ALPHA set to    100.000     (real)
 CNSsolve>      evaluate ($beta  =  80) 
 EVALUATE: symbol $BETA set to    80.0000     (real)
 CNSsolve>      evaluate ($gamma = 110) 
 EVALUATE: symbol $GAMMA set to    110.000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.137626     0.949856
     0.000000     5.873079    -0.665096
     0.000000     0.000000     5.345683
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:      330 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of       330 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       330 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of       330 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       330 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:        0 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       330 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Maps will be stored in P1:
   A=     0,...,     9  B=     0,...,    11  C=     0,...,     9
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P1 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   1
 Number of s.s.Vectors & Moduli =   3
   s.s.Vector  Modulus
     1  0  0   0
     0  1  0   0
     0  0  1   0
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =      1200
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0  10
 FMAP:   0  1  0  12
 FMAP:   0  0  1  10
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =         1
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =         1
 FMAP: Independent grid points =         1
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     330
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for         1 independent grid point(s)
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Reflections in asym. unit      330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0024 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0052 seconds Direct Translation Search
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =   0.119692E-03
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Used reflections               330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13     6
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =    0.00000    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.697553    
 PSEARCH: Number of peaks in overstore buffer =        1
 PSEARCH: Number of peaks listed              =        1
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.697553     Pos = ( 0.00000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    1.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =         1
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for         1 independent grid point(s)
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Reflections in asym. unit      330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0024 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0043 seconds Direct Translation Search
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =   0.119692E-03
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Used reflections               330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13     6
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =    0.00000    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.697553    
 PSEARCH: Number of peaks in overstore buffer =        1
 PSEARCH: Number of peaks listed              =        1
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.697553     Pos = ( 0.00000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    2.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =      1200
 FMAP: Independent grid points =      1200
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      1200 independent grid point(s)
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Reflections in asym. unit      330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0024 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.9924 seconds Direct Translation Search
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Used reflections               330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    4268.44    
 TSMAP: SmHdIFF =  178678.    
 TSMAP: SmHF2F2 =  91955.9    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13     6
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.607703    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.977632     Pos = ( 0.50000, 0.00000, 0.30000)
 PSEARCH:     2 Dens =   0.935184     Pos = ( 0.40000, 0.41667, 0.90000)
 PSEARCH:     3 Dens =   0.929331     Pos = ( 0.30000, 0.33333, 0.90000)
 PSEARCH:     4 Dens =   0.913800     Pos = ( 0.50000, 0.00000, 0.40000)
 PSEARCH:     5 Dens =   0.907242     Pos = ( 0.40000, 0.33333, 0.90000)
 PSEARCH:     6 Dens =   0.857409     Pos = ( 0.30000, 0.41667, 0.90000)
 PSEARCH:     7 Dens =   0.852147     Pos = ( 0.40000, 0.41667, 0.00000)
 PSEARCH:     8 Dens =   0.848074     Pos = ( 0.30000, 0.33333, 0.00000)
 PSEARCH:     9 Dens =   0.847893     Pos = ( 0.60000, 0.00000, 0.30000)
 PSEARCH:    10 Dens =   0.838869     Pos = ( 0.50000, 0.91667, 0.30000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    3.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =      1200
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      1200 independent grid point(s)
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Reflections in asym. unit      330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0024 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.5360 seconds Direct Translation Search
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Used reflections               330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    4268.44    
 TSMAP: SmHdIFF =  178678.    
 TSMAP: SmHF2F2 =  91955.9    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13     6
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    330
 TSMAP: Selected reflections           330
 TSMAP: Reflections in asym. unit      330
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0001 seconds Direct Translation Search
 TSMAP: tmin =     0.389422    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.607703    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.977632     Pos = ( 0.50000, 0.00000, 0.30000)
 PSEARCH:     2 Dens =   0.935184     Pos = ( 0.40000, 0.41667, 0.90000)
 PSEARCH:     3 Dens =   0.929332     Pos = ( 0.30000, 0.33333, 0.90000)
 PSEARCH:     4 Dens =   0.913801     Pos = ( 0.50000, 0.00000, 0.40000)
 PSEARCH:     5 Dens =   0.907242     Pos = ( 0.40000, 0.33333, 0.90000)
 PSEARCH:     6 Dens =   0.857409     Pos = ( 0.30000, 0.41667, 0.90000)
 PSEARCH:     7 Dens =   0.852147     Pos = ( 0.40000, 0.41667, 0.00000)
 PSEARCH:     8 Dens =   0.848075     Pos = ( 0.30000, 0.33333, 0.00000)
 PSEARCH:     9 Dens =   0.847894     Pos = ( 0.60000, 0.00000, 0.30000)
 PSEARCH:    10 Dens =   0.838869     Pos = ( 0.50000, 0.91667, 0.30000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    4.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P1 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha = 100) 
 EVALUATE: symbol $ALPHA set to    100.000     (real)
 CNSsolve>      evaluate ($beta  =  80) 
 EVALUATE: symbol $BETA set to    80.0000     (real)
 CNSsolve>      evaluate ($gamma = 110) 
 EVALUATE: symbol $GAMMA set to    110.000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.137626     0.949856
     0.000000     5.873079    -0.665096
     0.000000     0.000000     5.345683
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:      660 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of       660 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       660 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of       660 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       660 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:        0 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       660 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Maps will be stored in P1:
   A=     0,...,     9  B=     0,...,    11  C=     0,...,     9
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P1 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   1
 Number of s.s.Vectors & Moduli =   3
   s.s.Vector  Modulus
     1  0  0   0
     0  1  0   0
     0  0  1   0
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =      1200
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0  10
 FMAP:   0  1  0  12
 FMAP:   0  0  1  10
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =         1
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =         1
 FMAP: Independent grid points =         1
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     660
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for         1 independent grid point(s)
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Reflections in asym. unit      660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0073 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0103 seconds Direct Translation Search
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =   0.119692E-03
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Used reflections               660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13    11
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.697554    
 TSMAP: tmax =     0.697554    
 TSMAP: tave =     0.697554    
 TSMAP: tsigma =    0.00000    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.697554    
 PSEARCH: Number of peaks in overstore buffer =        1
 PSEARCH: Number of peaks listed              =        1
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.697554     Pos = ( 0.00000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    5.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =         1
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for         1 independent grid point(s)
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Reflections in asym. unit      660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0037 seconds Direct Translation Search
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =   0.119692E-03
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Used reflections               660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13    11
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Number of non-empty rows =           1 =     0.07 % of 2D array
 TSMAP: Total number of coefficients =           1 =     0.00 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =           1 =     0.19 % of 2D array
 TSMAP: Total number of coefficients =           1 =     0.01 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =           1 =     0.19 % of 2D array
 TSMAP: Total number of coefficients =           1 =     0.01 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.697553    
 TSMAP: tmax =     0.697553    
 TSMAP: tave =     0.697553    
 TSMAP: tsigma =    0.00000    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.697553    
 PSEARCH: Number of peaks in overstore buffer =        1
 PSEARCH: Number of peaks listed              =        1
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.697553     Pos = ( 0.00000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    6.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =      1200
 FMAP: Independent grid points =      1200
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      1200 independent grid point(s)
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Reflections in asym. unit      660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     1.0057 seconds Direct Translation Search
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Used reflections               660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    4268.44    
 TSMAP: SmHdIFF =  178678.    
 TSMAP: SmHF2F2 =  91955.9    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13    11
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Number of non-empty rows =          88 =     5.87 % of 2D array
 TSMAP: Total number of coefficients =         706 =     0.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.02273    

 TSMAP: Number of non-empty rows =          51 =     9.44 % of 2D array
 TSMAP: Total number of coefficients =         380 =     2.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    7.45098    

 TSMAP: Number of non-empty rows =          51 =     9.44 % of 2D array
 TSMAP: Total number of coefficients =         380 =     2.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    7.45098    

 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.607703    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.977632     Pos = ( 0.50000, 0.00000, 0.30000)
 PSEARCH:     2 Dens =   0.935184     Pos = ( 0.40000, 0.41667, 0.90000)
 PSEARCH:     3 Dens =   0.929331     Pos = ( 0.30000, 0.33333, 0.90000)
 PSEARCH:     4 Dens =   0.913800     Pos = ( 0.50000, 0.00000, 0.40000)
 PSEARCH:     5 Dens =   0.907242     Pos = ( 0.40000, 0.33333, 0.90000)
 PSEARCH:     6 Dens =   0.857409     Pos = ( 0.30000, 0.41667, 0.90000)
 PSEARCH:     7 Dens =   0.852147     Pos = ( 0.40000, 0.41667, 0.00000)
 PSEARCH:     8 Dens =   0.848074     Pos = ( 0.30000, 0.33333, 0.00000)
 PSEARCH:     9 Dens =   0.847893     Pos = ( 0.60000, 0.00000, 0.30000)
 PSEARCH:    10 Dens =   0.838869     Pos = ( 0.50000, 0.91667, 0.30000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    7.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  12,  10] and sublattice [  10,  12,  10]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    10  B=     0,...,    12  C=     0,...,    10
 Number of deleted points in ASU=           0
 Number of non-zero lattice points in ASU=        1200
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =      1200
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      1200 independent grid point(s)
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Reflections in asym. unit      660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0757 seconds Direct Translation Search
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Used reflections               660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: SmH =              660
 TSMAP: SmHdI2 =  0.102391E+07
 TSMAP: SmHFF =    4268.44    
 TSMAP: SmHdIFF =  178678.    
 TSMAP: SmHF2F2 =  91955.9    
 TSMAP: hfcg =      5     6     5
 TSMAP: nfcg =     11    13    11
 TSMAP: uFFTgrid set to    3   3   3
 TSMAP: vFFTgrid set to    5   5   5
 TSMAP: Dimensions of scratch array U =    30(  34)   36(  37)   30(  30)
 TSMAP: Dimensions of scratch array V =    50(  54)   60(  61)   50(  50)
 TSMAP: Number of non-empty rows =          88 =     5.87 % of 2D array
 TSMAP: Total number of coefficients =         706 =     0.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.02273    

 TSMAP: Number of non-empty rows =          51 =     9.44 % of 2D array
 TSMAP: Total number of coefficients =         380 =     2.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    7.45098    

 TSMAP: Number of non-empty rows =          51 =     9.44 % of 2D array
 TSMAP: Total number of coefficients =         380 =     2.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    7.45098    

 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    660
 TSMAP: Selected reflections           660
 TSMAP: Reflections in asym. unit      660
 TSMAP: Sym. equiv. reflections          0
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0003 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0004 seconds Direct Translation Search
 TSMAP: tmin =     0.389421    
 TSMAP: tmax =     0.977632    
 TSMAP: tave =     0.504565    
 TSMAP: tsigma =   0.736221E-01
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.607703    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.977632     Pos = ( 0.50000, 0.00000, 0.30000)
 PSEARCH:     2 Dens =   0.935184     Pos = ( 0.40000, 0.41667, 0.90000)
 PSEARCH:     3 Dens =   0.929331     Pos = ( 0.30000, 0.33333, 0.90000)
 PSEARCH:     4 Dens =   0.913800     Pos = ( 0.50000, 0.00000, 0.40000)
 PSEARCH:     5 Dens =   0.907242     Pos = ( 0.40000, 0.33333, 0.90000)
 PSEARCH:     6 Dens =   0.857409     Pos = ( 0.30000, 0.41667, 0.90000)
 PSEARCH:     7 Dens =   0.852147     Pos = ( 0.40000, 0.41667, 0.00000)
 PSEARCH:     8 Dens =   0.848074     Pos = ( 0.30000, 0.33333, 0.00000)
 PSEARCH:     9 Dens =   0.847893     Pos = ( 0.60000, 0.00000, 0.30000)
 PSEARCH:    10 Dens =   0.838869     Pos = ( 0.50000, 0.91667, 0.30000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    8.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "C2/c" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($fcx=fcalc) 
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 Assuming literal string "FCALCX"
 EVALUATE: symbol $FCX set to "FCALCX" (string)
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group C2/c in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  80) 
 EVALUATE: symbol $BETA set to    80.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.949856
     0.000000     6.250000     0.000000
     0.000000     0.000000     5.386898
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       87 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        87 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        87 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        87 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        87 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:       73 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       160 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group C2/c in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   8
 Number of s.s.Vectors & Moduli =   2
   s.s.Vector  Modulus
     1  0  0   2
     0  0  1   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-X,Y,-Z+1/2)
 | SYMMetry=(-X,-Y,-Z)
 | SYMMetry=(X,-Y,Z+1/2)
 | SYMMetry=(X+1/2,Y+1/2,Z)
 | SYMMetry=(-X+1/2,Y+1/2,-Z+1/2)
 | SYMMetry=(-X+1/2,-Y+1/2,-Z)
 | SYMMetry=(X+1/2,-Y+1/2,Z+1/2)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       224
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0   2
 FMAP:   0  0  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        80
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        80
 FMAP: Independent grid points =        80
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     160
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        80 independent grid point(s)
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0037 seconds Direct Translation Search
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13     6
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Number of non-empty rows =          79 =     7.31 % of 2D array
 TSMAP: Total number of coefficients =         660 =     1.27 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.35443    

 TSMAP: Number of non-empty rows =          33 =     7.64 % of 2D array
 TSMAP: Total number of coefficients =         225 =     2.17 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    6.81818    

 TSMAP: Number of non-empty rows =          33 =     7.64 % of 2D array
 TSMAP: Total number of coefficients =         225 =     2.17 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    6.81818    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.128569E-02
 PSEARCH: Number of peaks in overstore buffer =       80
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.652072     Pos = ( 0.00000, 0.08333, 0.08333)
 PSEARCH:     4 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.25000)
 PSEARCH:     6 Dens =   0.647553     Pos = ( 0.00000, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.599414     Pos = ( 0.00000, 0.08333, 0.16667)
 PSEARCH:     8 Dens =   0.512805     Pos = ( 0.08333, 0.00000, 0.08333)
 PSEARCH:     9 Dens =   0.512805     Pos = ( 0.41667, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.505059     Pos = ( 0.41667, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    9.00000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        80
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        80 independent grid point(s)
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0037 seconds Direct Translation Search
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13     6
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Number of non-empty rows =          79 =     7.31 % of 2D array
 TSMAP: Total number of coefficients =         660 =     1.27 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.35443    

 TSMAP: Number of non-empty rows =          33 =     7.64 % of 2D array
 TSMAP: Total number of coefficients =         225 =     2.17 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    6.81818    

 TSMAP: Number of non-empty rows =          33 =     7.64 % of 2D array
 TSMAP: Total number of coefficients =         225 =     2.17 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    6.81818    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.128569E-02
 PSEARCH: Number of peaks in overstore buffer =       80
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.652072     Pos = ( 0.00000, 0.08333, 0.08333)
 PSEARCH:     4 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.25000)
 PSEARCH:     6 Dens =   0.647553     Pos = ( 0.00000, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.599414     Pos = ( 0.00000, 0.08333, 0.16667)
 PSEARCH:     8 Dens =   0.512805     Pos = ( 0.08333, 0.00000, 0.08333)
 PSEARCH:     9 Dens =   0.512805     Pos = ( 0.41667, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.505059     Pos = ( 0.41667, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    10.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       224
 FMAP: Independent grid points =       224
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       224 independent grid point(s)
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0109 seconds Direct Translation Search
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231578    
 TSMAP: tsigma =   0.207137    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    33285.3    
 TSMAP: SmHdIFF = 0.266637E+08
 TSMAP: SmHF2F2 = 0.194485E+08
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13     6
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.657184E-01
 TSMAP: tmax =     0.999898    
 TSMAP: tave =     0.231564    
 TSMAP: tsigma =   0.207126    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.182995    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999898     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.944803     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.813721     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     4 Dens =   0.723933     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.711167     Pos = ( 0.00000, 0.41667, 0.08333)
 PSEARCH:     6 Dens =   0.710518     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     7 Dens =   0.708883     Pos = ( 0.08333, 0.50000, 0.16667)
 PSEARCH:     8 Dens =   0.706533     Pos = ( 0.00000, 0.41667, 0.16667)
 PSEARCH:     9 Dens =   0.702455     Pos = ( 0.50000, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.694729     Pos = ( 0.08333, 0.50000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    11.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       224
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       224 independent grid point(s)
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0115 seconds Direct Translation Search
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231167    
 TSMAP: tsigma =   0.206547    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    33285.3    
 TSMAP: SmHdIFF = 0.266637E+08
 TSMAP: SmHF2F2 = 0.194485E+08
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13     6
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    160
 TSMAP: Selected reflections           160
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections         73
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0015 seconds Direct Translation Search
 TSMAP: tmin =    -0.657184E-01
 TSMAP: tmax =     0.999898    
 TSMAP: tave =     0.231154    
 TSMAP: tsigma =   0.206536    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.182995    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999898     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.944803     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.822292     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     4 Dens =   0.711167     Pos = ( 0.00000, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.710518     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     6 Dens =   0.708883     Pos = ( 0.08333, 0.50000, 0.16667)
 PSEARCH:     7 Dens =   0.706533     Pos = ( 0.00000, 0.41667, 0.16667)
 PSEARCH:     8 Dens =   0.702455     Pos = ( 0.50000, 0.08333, 0.00000)
 PSEARCH:     9 Dens =   0.694729     Pos = ( 0.08333, 0.50000, 0.08333)
 PSEARCH:    10 Dens =   0.690159     Pos = ( 0.50000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    12.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group C2/c in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  80) 
 EVALUATE: symbol $BETA set to    80.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.949856
     0.000000     6.250000     0.000000
     0.000000     0.000000     5.386898
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       87 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        87 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        87 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        87 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        87 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      233 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       320 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group C2/c in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   8
 Number of s.s.Vectors & Moduli =   2
   s.s.Vector  Modulus
     1  0  0   2
     0  0  1   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-X,Y,-Z+1/2)
 | SYMMetry=(-X,-Y,-Z)
 | SYMMetry=(X,-Y,Z+1/2)
 | SYMMetry=(X+1/2,Y+1/2,Z)
 | SYMMetry=(-X+1/2,Y+1/2,-Z+1/2)
 | SYMMetry=(-X+1/2,-Y+1/2,-Z)
 | SYMMetry=(X+1/2,-Y+1/2,Z+1/2)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       224
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0   2
 FMAP:   0  0  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        80
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        80
 FMAP: Independent grid points =        80
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     320
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        80 independent grid point(s)
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0167 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.1220 seconds Direct Translation Search
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13    11
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.128569E-02
 PSEARCH: Number of peaks in overstore buffer =       80
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.652072     Pos = ( 0.00000, 0.08333, 0.08333)
 PSEARCH:     4 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.25000)
 PSEARCH:     6 Dens =   0.647553     Pos = ( 0.00000, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.599414     Pos = ( 0.00000, 0.08333, 0.16667)
 PSEARCH:     8 Dens =   0.512805     Pos = ( 0.08333, 0.00000, 0.08333)
 PSEARCH:     9 Dens =   0.512805     Pos = ( 0.41667, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.505059     Pos = ( 0.41667, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    13.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        80
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        80 independent grid point(s)
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0006 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0052 seconds Direct Translation Search
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13    11
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =    -0.128569E-02
 TSMAP: tmax =     0.843011    
 TSMAP: tave =     0.230710    
 TSMAP: tsigma =   0.185315    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.128569E-02
 PSEARCH: Number of peaks in overstore buffer =       80
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.843011     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.652072     Pos = ( 0.00000, 0.08333, 0.08333)
 PSEARCH:     4 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.651044     Pos = ( 0.00000, 0.00000, 0.25000)
 PSEARCH:     6 Dens =   0.647553     Pos = ( 0.00000, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.599414     Pos = ( 0.00000, 0.08333, 0.16667)
 PSEARCH:     8 Dens =   0.512805     Pos = ( 0.08333, 0.00000, 0.08333)
 PSEARCH:     9 Dens =   0.512805     Pos = ( 0.41667, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.505059     Pos = ( 0.41667, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    14.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       224
 FMAP: Independent grid points =       224
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       224 independent grid point(s)
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0006 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0138 seconds Direct Translation Search
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231578    
 TSMAP: tsigma =   0.207137    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    33285.3    
 TSMAP: SmHdIFF = 0.266637E+08
 TSMAP: SmHF2F2 = 0.194485E+08
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13    11
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231578    
 TSMAP: tsigma =   0.207137    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.183002    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999943     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.944843     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.813745     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     4 Dens =   0.723952     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.711208     Pos = ( 0.00000, 0.41667, 0.08333)
 PSEARCH:     6 Dens =   0.710556     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     7 Dens =   0.708926     Pos = ( 0.08333, 0.50000, 0.16667)
 PSEARCH:     8 Dens =   0.706570     Pos = ( 0.00000, 0.41667, 0.16667)
 PSEARCH:     9 Dens =   0.702483     Pos = ( 0.50000, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.694770     Pos = ( 0.08333, 0.50000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    15.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=     0,...,     6
 Number of deleted points in ASU=         119
 Number of non-zero lattice points in ASU=         224
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       224
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       224 independent grid point(s)
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0139 seconds Direct Translation Search
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231167    
 TSMAP: tsigma =   0.206547    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Used reflections                87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: SmH =              320
 TSMAP: SmHdI2 =  0.541296E+09
 TSMAP: SmHFF =    33285.3    
 TSMAP: SmHdIFF = 0.266637E+08
 TSMAP: SmHF2F2 = 0.194485E+08
 TSMAP: hfcg =      4     6     5
 TSMAP: nfcg =      9    13    11
 TSMAP: uFFTgrid set to    2   3   2
 TSMAP: vFFTgrid set to    3   5   4
 TSMAP: Dimensions of scratch array U =    24(  26)   36(  37)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   60(  61)   48(  48)
 TSMAP: Number of non-empty rows =         107 =     9.91 % of 2D array
 TSMAP: Total number of coefficients =        1142 =     2.20 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          23
 TSMAP:    Mean number of coefficients per non-empty row =    10.6729    

 TSMAP: Number of non-empty rows =          47 =    10.88 % of 2D array
 TSMAP: Total number of coefficients =         373 =     3.60 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          16
 TSMAP:    Mean number of coefficients per non-empty row =    7.93617    

 TSMAP: Number of non-empty rows =          47 =    10.88 % of 2D array
 TSMAP: Total number of coefficients =         373 =     3.60 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          16
 TSMAP:    Mean number of coefficients per non-empty row =    7.93617    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    320
 TSMAP: Selected reflections           320
 TSMAP: Reflections in asym. unit       87
 TSMAP: Sym. equiv. reflections        233
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0006 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0024 seconds Direct Translation Search
 TSMAP: tmin =    -0.657233E-01
 TSMAP: tmax =     0.999943    
 TSMAP: tave =     0.231167    
 TSMAP: tsigma =   0.206547    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.183002    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999943     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.944843     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.822292     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     4 Dens =   0.711208     Pos = ( 0.00000, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.710556     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:     6 Dens =   0.708926     Pos = ( 0.08333, 0.50000, 0.16667)
 PSEARCH:     7 Dens =   0.706570     Pos = ( 0.00000, 0.41667, 0.16667)
 PSEARCH:     8 Dens =   0.702483     Pos = ( 0.50000, 0.08333, 0.00000)
 PSEARCH:     9 Dens =   0.694770     Pos = ( 0.08333, 0.50000, 0.08333)
 PSEARCH:    10 Dens =   0.690159     Pos = ( 0.50000, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    16.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "Fddd" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($fcx=fcalc) 
 Assuming literal string "FCALC"
 EVALUATE: symbol $FCX set to "FCALC" (string)
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group Fddd in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     6.250000     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       22 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of        22 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        22 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        22 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        22 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:       49 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        71 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Maps will be stored in P1:
   A=     0,...,    15  B=     0,...,    15  C=     0,...,    15
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group Fddd in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  32
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     1  0  0   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-X+1/4,-Y+1/4,-Z+1/4)
 | SYMMetry=(-X,-Y,Z)
 | SYMMetry=(X,-Y,-Z)
 | SYMMetry=(-X,Y,-Z)
 | SYMMetry=(X+1/4,Y+1/4,-Z+1/4)
 | SYMMetry=(-X+1/4,Y+1/4,Z+1/4)
 | SYMMetry=(X+1/4,-Y+1/4,Z+1/4)
 | SYMMetry=(X,Y+1/2,Z+1/2)
 | SYMMetry=(-X+1/4,-Y+3/4,-Z+3/4)
 | SYMMetry=(-X,-Y+1/2,Z+1/2)
 | SYMMetry=(X,-Y+1/2,-Z+1/2)
 | SYMMetry=(-X,Y+1/2,-Z+1/2)
 | SYMMetry=(X+1/4,Y+3/4,-Z+3/4)
 | SYMMetry=(-X+1/4,Y+3/4,Z+3/4)
 | SYMMetry=(X+1/4,-Y+3/4,Z+3/4)
 | SYMMetry=(X+1/2,Y,Z+1/2)
 | SYMMetry=(-X+3/4,-Y+1/4,-Z+3/4)
 | SYMMetry=(-X+1/2,-Y,Z+1/2)
 | SYMMetry=(X+1/2,-Y,-Z+1/2)
 | SYMMetry=(-X+1/2,Y,-Z+1/2)
 | SYMMetry=(X+3/4,Y+1/4,-Z+3/4)
 | SYMMetry=(-X+3/4,Y+1/4,Z+3/4)
 | SYMMetry=(X+3/4,-Y+1/4,Z+3/4)
 | SYMMetry=(X+1/2,Y+1/2,Z)
 | SYMMetry=(-X+3/4,-Y+3/4,-Z+1/4)
 | SYMMetry=(-X+1/2,-Y+1/2,Z)
 | SYMMetry=(X+1/2,-Y+1/2,-Z)
 | SYMMetry=(-X+1/2,Y+1/2,-Z)
 | SYMMetry=(X+3/4,Y+3/4,-Z+1/4)
 | SYMMetry=(-X+3/4,Y+3/4,Z+1/4)
 | SYMMetry=(X+3/4,-Y+3/4,Z+1/4)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =       141
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0   2
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =        77
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =        77
 FMAP: Independent grid points =        77
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections      71
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        77 independent grid point(s)
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0014 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0844 seconds Direct Translation Search
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564308    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Number of non-empty rows =          77 =     6.68 % of 2D array
 TSMAP: Total number of coefficients =         719 =     1.30 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.33766    

 TSMAP: Number of non-empty rows =          31 =     6.05 % of 2D array
 TSMAP: Total number of coefficients =         161 =     0.98 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.19355    

 TSMAP: Number of non-empty rows =          31 =     6.05 % of 2D array
 TSMAP: Total number of coefficients =         161 =     0.98 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.19355    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564309    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.555663E-01
 PSEARCH: Number of peaks in overstore buffer =       77
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.564309     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     2 Dens =   0.541564     Pos = ( 0.06250, 0.12500, 0.00000)
 PSEARCH:     3 Dens =   0.537750     Pos = ( 0.06250, 0.18750, 0.00000)
 PSEARCH:     4 Dens =   0.523493     Pos = ( 0.06250, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.513022     Pos = ( 0.06250, 0.12500, 0.12500)
 PSEARCH:     6 Dens =   0.500321     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.499748     Pos = ( 0.12500, 0.12500, 0.00000)
 PSEARCH:     8 Dens =   0.499748     Pos = ( 0.00000, 0.12500, 0.12500)
 PSEARCH:     9 Dens =   0.499748     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.429321     Pos = ( 0.00000, 0.18750, 0.12500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    17.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        77
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        77 independent grid point(s)
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0035 seconds Direct Translation Search
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564308    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Number of non-empty rows =          77 =     6.68 % of 2D array
 TSMAP: Total number of coefficients =         719 =     1.30 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.33766    

 TSMAP: Number of non-empty rows =          31 =     6.05 % of 2D array
 TSMAP: Total number of coefficients =         161 =     0.98 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.19355    

 TSMAP: Number of non-empty rows =          31 =     6.05 % of 2D array
 TSMAP: Total number of coefficients =         161 =     0.98 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.19355    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564309    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.555663E-01
 PSEARCH: Number of peaks in overstore buffer =       77
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.564309     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     2 Dens =   0.541564     Pos = ( 0.06250, 0.12500, 0.00000)
 PSEARCH:     3 Dens =   0.537750     Pos = ( 0.06250, 0.18750, 0.00000)
 PSEARCH:     4 Dens =   0.523493     Pos = ( 0.06250, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.513022     Pos = ( 0.06250, 0.12500, 0.12500)
 PSEARCH:     6 Dens =   0.500321     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.499748     Pos = ( 0.12500, 0.12500, 0.00000)
 PSEARCH:     8 Dens =   0.499748     Pos = ( 0.00000, 0.12500, 0.12500)
 PSEARCH:     9 Dens =   0.499748     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.429321     Pos = ( 0.00000, 0.18750, 0.12500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    18.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =       141
 FMAP: Independent grid points =       141
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       141 independent grid point(s)
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0066 seconds Direct Translation Search
 TSMAP: tmin =    -0.809608E-02
 TSMAP: tmax =     0.756456    
 TSMAP: tave =     0.302270    
 TSMAP: tsigma =   0.160847    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    88375.4    
 TSMAP: SmHdIFF = 0.180376E+09
 TSMAP: SmHF2F2 = 0.179487E+09
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Number of non-empty rows =         103 =     8.94 % of 2D array
 TSMAP: Total number of coefficients =         907 =     1.64 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.80583    

 TSMAP: Number of non-empty rows =          45 =     8.79 % of 2D array
 TSMAP: Total number of coefficients =         217 =     1.32 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           2
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    4.82222    

 TSMAP: Number of non-empty rows =          45 =     8.79 % of 2D array
 TSMAP: Total number of coefficients =         217 =     1.32 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           2
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    4.82222    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.809607E-02
 TSMAP: tmax =     0.756456    
 TSMAP: tave =     0.302270    
 TSMAP: tsigma =   0.160847    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.181549    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.756456     Pos = ( 0.06250, 0.12500, 0.62500)
 PSEARCH:     2 Dens =   0.753757     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     3 Dens =   0.713754     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     4 Dens =   0.700268     Pos = ( 0.00000, 0.00000, 0.12500)
 PSEARCH:     5 Dens =   0.679348     Pos = ( 0.12500, 0.12500, 0.62500)
 PSEARCH:     6 Dens =   0.658035     Pos = ( 0.06250, 0.12500, 0.68750)
 PSEARCH:     7 Dens =   0.652492     Pos = ( 0.00000, 0.00000, 0.18750)
 PSEARCH:     8 Dens =   0.625247     Pos = ( 0.00000, 0.12500, 0.37500)
 PSEARCH:     9 Dens =   0.613184     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.575741     Pos = ( 0.06250, 0.18750, 0.62500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    19.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       141
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       141 independent grid point(s)
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0136 seconds Direct Translation Search
 TSMAP: tmin =    -0.491629E-01
 TSMAP: tmax =     0.866083    
 TSMAP: tave =     0.300720    
 TSMAP: tsigma =   0.167791    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    88375.4    
 TSMAP: SmHdIFF = 0.180376E+09
 TSMAP: SmHF2F2 = 0.179487E+09
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Number of non-empty rows =         103 =     8.94 % of 2D array
 TSMAP: Total number of coefficients =         907 =     1.64 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.80583    

 TSMAP: Number of non-empty rows =          45 =     8.79 % of 2D array
 TSMAP: Total number of coefficients =         217 =     1.32 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           2
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    4.82222    

 TSMAP: Number of non-empty rows =          45 =     8.79 % of 2D array
 TSMAP: Total number of coefficients =         217 =     1.32 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           2
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    4.82222    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections     71
 TSMAP: Selected reflections            71
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections         49
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0085 seconds Direct Translation Search
 TSMAP: tmin =    -0.491629E-01
 TSMAP: tmax =     0.866083    
 TSMAP: tave =     0.300720    
 TSMAP: tsigma =   0.167791    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.179649    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.866083     Pos = ( 0.00000, 0.00000, 0.18750)
 PSEARCH:     2 Dens =   0.801159     Pos = ( 0.12500, 0.12500, 0.62500)
 PSEARCH:     3 Dens =   0.792086     Pos = ( 0.00000, 0.00000, 0.12500)
 PSEARCH:     4 Dens =   0.756456     Pos = ( 0.06250, 0.12500, 0.62500)
 PSEARCH:     5 Dens =   0.753757     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     6 Dens =   0.713754     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.658035     Pos = ( 0.06250, 0.12500, 0.68750)
 PSEARCH:     8 Dens =   0.625247     Pos = ( 0.00000, 0.12500, 0.37500)
 PSEARCH:     9 Dens =   0.613184     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.575741     Pos = ( 0.06250, 0.18750, 0.62500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    20.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group Fddd in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = 6.25) 
 EVALUATE: symbol $B set to    6.25000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     6.250000     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       22 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of        22 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        22 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        22 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        22 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      120 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       142 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Maps will be stored in P1:
   A=     0,...,    15  B=     0,...,    15  C=     0,...,    15
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group Fddd in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  32
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     1  0  0   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-X+1/4,-Y+1/4,-Z+1/4)
 | SYMMetry=(-X,-Y,Z)
 | SYMMetry=(X,-Y,-Z)
 | SYMMetry=(-X,Y,-Z)
 | SYMMetry=(X+1/4,Y+1/4,-Z+1/4)
 | SYMMetry=(-X+1/4,Y+1/4,Z+1/4)
 | SYMMetry=(X+1/4,-Y+1/4,Z+1/4)
 | SYMMetry=(X,Y+1/2,Z+1/2)
 | SYMMetry=(-X+1/4,-Y+3/4,-Z+3/4)
 | SYMMetry=(-X,-Y+1/2,Z+1/2)
 | SYMMetry=(X,-Y+1/2,-Z+1/2)
 | SYMMetry=(-X,Y+1/2,-Z+1/2)
 | SYMMetry=(X+1/4,Y+3/4,-Z+3/4)
 | SYMMetry=(-X+1/4,Y+3/4,Z+3/4)
 | SYMMetry=(X+1/4,-Y+3/4,Z+3/4)
 | SYMMetry=(X+1/2,Y,Z+1/2)
 | SYMMetry=(-X+3/4,-Y+1/4,-Z+3/4)
 | SYMMetry=(-X+1/2,-Y,Z+1/2)
 | SYMMetry=(X+1/2,-Y,-Z+1/2)
 | SYMMetry=(-X+1/2,Y,-Z+1/2)
 | SYMMetry=(X+3/4,Y+1/4,-Z+3/4)
 | SYMMetry=(-X+3/4,Y+1/4,Z+3/4)
 | SYMMetry=(X+3/4,-Y+1/4,Z+3/4)
 | SYMMetry=(X+1/2,Y+1/2,Z)
 | SYMMetry=(-X+3/4,-Y+3/4,-Z+1/4)
 | SYMMetry=(-X+1/2,-Y+1/2,Z)
 | SYMMetry=(X+1/2,-Y+1/2,-Z)
 | SYMMetry=(-X+1/2,Y+1/2,-Z)
 | SYMMetry=(X+3/4,Y+3/4,-Z+1/4)
 | SYMMetry=(-X+3/4,Y+3/4,Z+1/4)
 | SYMMetry=(X+3/4,-Y+3/4,Z+1/4)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =       141
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  0  0   2
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =        77
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =        77
 FMAP: Independent grid points =        77
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     142
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        77 independent grid point(s)
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0186 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.1168 seconds Direct Translation Search
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564308    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564309    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.555663E-01
 PSEARCH: Number of peaks in overstore buffer =       77
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.564309     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     2 Dens =   0.541564     Pos = ( 0.06250, 0.12500, 0.00000)
 PSEARCH:     3 Dens =   0.537750     Pos = ( 0.06250, 0.18750, 0.00000)
 PSEARCH:     4 Dens =   0.523493     Pos = ( 0.06250, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.513022     Pos = ( 0.06250, 0.12500, 0.12500)
 PSEARCH:     6 Dens =   0.500321     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.499748     Pos = ( 0.12500, 0.12500, 0.00000)
 PSEARCH:     8 Dens =   0.499748     Pos = ( 0.00000, 0.12500, 0.12500)
 PSEARCH:     9 Dens =   0.499748     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.429321     Pos = ( 0.00000, 0.18750, 0.12500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    21.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        77
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        77 independent grid point(s)
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0049 seconds Direct Translation Search
 TSMAP: tmin =     0.555663E-01
 TSMAP: tmax =     0.564308    
 TSMAP: tave =     0.299055    
 TSMAP: tsigma =   0.120418    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.557124E-01
 TSMAP: tmax =     0.563829    
 TSMAP: tave =     0.299263    
 TSMAP: tsigma =   0.120241    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0019
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.557124E-01
 PSEARCH: Number of peaks in overstore buffer =       77
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.563829     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     2 Dens =   0.541090     Pos = ( 0.06250, 0.12500, 0.00000)
 PSEARCH:     3 Dens =   0.536772     Pos = ( 0.06250, 0.18750, 0.00000)
 PSEARCH:     4 Dens =   0.523056     Pos = ( 0.06250, 0.00000, 0.00000)
 PSEARCH:     5 Dens =   0.512890     Pos = ( 0.06250, 0.12500, 0.12500)
 PSEARCH:     6 Dens =   0.501005     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.499938     Pos = ( 0.00000, 0.12500, 0.12500)
 PSEARCH:     8 Dens =   0.499063     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:     9 Dens =   0.499015     Pos = ( 0.12500, 0.12500, 0.00000)
 PSEARCH:    10 Dens =   0.429098     Pos = ( 0.00000, 0.18750, 0.12500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    22.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      4096
 FMAP: Remaining independent grid points =       141
 FMAP: Independent grid points =       141
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       141 independent grid point(s)
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0085 seconds Direct Translation Search
 TSMAP: tmin =    -0.809608E-02
 TSMAP: tmax =     0.756456    
 TSMAP: tave =     0.302270    
 TSMAP: tsigma =   0.160847    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    88375.4    
 TSMAP: SmHdIFF = 0.180376E+09
 TSMAP: SmHF2F2 = 0.179487E+09
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.810906E-02
 TSMAP: tmax =     0.756357    
 TSMAP: tave =     0.302506    
 TSMAP: tsigma =   0.160923    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0030
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.181514    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.756357     Pos = ( 0.06250, 0.12500, 0.62500)
 PSEARCH:     2 Dens =   0.753334     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     3 Dens =   0.714682     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     4 Dens =   0.700041     Pos = ( 0.00000, 0.00000, 0.12500)
 PSEARCH:     5 Dens =   0.679181     Pos = ( 0.12500, 0.12500, 0.62500)
 PSEARCH:     6 Dens =   0.661012     Pos = ( 0.06250, 0.12500, 0.68750)
 PSEARCH:     7 Dens =   0.653225     Pos = ( 0.00000, 0.00000, 0.18750)
 PSEARCH:     8 Dens =   0.625410     Pos = ( 0.00000, 0.12500, 0.37500)
 PSEARCH:     9 Dens =   0.612829     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.575403     Pos = ( 0.06250, 0.18750, 0.62500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    23.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  16,  16,  16] and sublattice [  16,  16,  16]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     2  B=     0,...,     4  C=     0,...,    16
 Number of deleted points in ASU=          99
 Number of non-zero lattice points in ASU=         141
 Number of special positions in ASU=          25
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       141
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       141 independent grid point(s)
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0155 seconds Direct Translation Search
 TSMAP: tmin =    -0.491629E-01
 TSMAP: tmax =     0.866083    
 TSMAP: tave =     0.300720    
 TSMAP: tsigma =   0.167791    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Used reflections                22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: SmH =              142
 TSMAP: SmHdI2 =  0.134735E+10
 TSMAP: SmHFF =    88375.4    
 TSMAP: SmHdIFF = 0.180376E+09
 TSMAP: SmHF2F2 = 0.179487E+09
 TSMAP: hfcg =      4     5     5
 TSMAP: nfcg =      9    11    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    32(  34)   32(  33)   32(  32)
 TSMAP: Dimensions of scratch array V =    48(  50)   48(  49)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    142
 TSMAP: Selected reflections           142
 TSMAP: Reflections in asym. unit       22
 TSMAP: Sym. equiv. reflections        120
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0086 seconds Direct Translation Search
 TSMAP: tmin =    -0.491629E-01
 TSMAP: tmax =     0.866083    
 TSMAP: tave =     0.300961    
 TSMAP: tsigma =   0.167864    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      4096 elements =                 0.0030
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.179649    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.866083     Pos = ( 0.00000, 0.00000, 0.18750)
 PSEARCH:     2 Dens =   0.801159     Pos = ( 0.12500, 0.12500, 0.62500)
 PSEARCH:     3 Dens =   0.792086     Pos = ( 0.00000, 0.00000, 0.12500)
 PSEARCH:     4 Dens =   0.756357     Pos = ( 0.06250, 0.12500, 0.62500)
 PSEARCH:     5 Dens =   0.753334     Pos = ( 0.06250, 0.00000, 0.12500)
 PSEARCH:     6 Dens =   0.714682     Pos = ( 0.06250, 0.00000, 0.18750)
 PSEARCH:     7 Dens =   0.661012     Pos = ( 0.06250, 0.12500, 0.68750)
 PSEARCH:     8 Dens =   0.625410     Pos = ( 0.00000, 0.12500, 0.37500)
 PSEARCH:     9 Dens =   0.612829     Pos = ( 0.12500, 0.00000, 0.12500)
 PSEARCH:    10 Dens =   0.575403     Pos = ( 0.06250, 0.18750, 0.62500)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    24.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "I-4c2" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($fcx=fcalc) 
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 Assuming literal string "FCALCX"
 EVALUATE: symbol $FCX set to "FCALCX" (string)
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group I-4c2 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     5.010000     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       26 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        26 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        26 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        26 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        26 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:       98 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       124 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Maps will be stored in P1:
   A=     0,...,     9  B=     0,...,     9  C=     0,...,    11
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group I-4c2 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  16
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     2  0  1   4
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(Y,-X,-Z)
 | SYMMetry=(-X,-Y,Z)
 | SYMMetry=(-Y,X,-Z)
 | SYMMetry=(Y,X,-Z+1/2)
 | SYMMetry=(-Y,-X,-Z+1/2)
 | SYMMetry=(-X,Y,Z+1/2)
 | SYMMetry=(X,-Y,Z+1/2)
 | SYMMetry=(X+1/2,Y+1/2,Z+1/2)
 | SYMMetry=(Y+1/2,-X+1/2,-Z+1/2)
 | SYMMetry=(-X+1/2,-Y+1/2,Z+1/2)
 | SYMMetry=(-Y+1/2,X+1/2,-Z+1/2)
 | SYMMetry=(Y+1/2,X+1/2,-Z)
 | SYMMetry=(-Y+1/2,-X+1/2,-Z)
 | SYMMetry=(-X+1/2,Y+1/2,Z)
 | SYMMetry=(X+1/2,-Y+1/2,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        84
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   2  0  1   4
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        30
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        24
 FMAP: Independent grid points =        24
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     124
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        24 independent grid point(s)
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Reflections in asym. unit       26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0003 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0013 seconds Direct Translation Search
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Used reflections                26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.749321E-01
 PSEARCH: Number of peaks in overstore buffer =       24
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.886675     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.886675     Pos = ( 0.10000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.809080     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.809080     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     5 Dens =   0.656239     Pos = ( 0.00000, 0.10000, 0.00000)
 PSEARCH:     6 Dens =   0.656239     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:     7 Dens =   0.652217     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.652217     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     9 Dens =   0.555808     Pos = ( 0.10000, 0.10000, 0.08333)
 PSEARCH:    10 Dens =   0.534021     Pos = ( 0.40000, 0.10000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    25.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        24
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        24 independent grid point(s)
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Reflections in asym. unit       26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0010 seconds Direct Translation Search
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Used reflections                26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Number of non-empty rows =         192 =    24.00 % of 2D array
 TSMAP: Total number of coefficients =         976 =     3.39 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    5.08333    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.749321E-01
 PSEARCH: Number of peaks in overstore buffer =       24
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.886675     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.886675     Pos = ( 0.10000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.809080     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.809080     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     5 Dens =   0.656239     Pos = ( 0.00000, 0.10000, 0.00000)
 PSEARCH:     6 Dens =   0.656239     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:     7 Dens =   0.652217     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.652217     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     9 Dens =   0.555808     Pos = ( 0.10000, 0.10000, 0.08333)
 PSEARCH:    10 Dens =   0.534021     Pos = ( 0.40000, 0.10000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    26.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        84
 FMAP: Independent grid points =        84
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for        84 independent grid point(s)
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Reflections in asym. unit       26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0033 seconds Direct Translation Search
 TSMAP: tmin =    -0.680694E-01
 TSMAP: tmax =     0.961643    
 TSMAP: tave =     0.357912    
 TSMAP: tsigma =   0.276736    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Used reflections                26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    44185.9    
 TSMAP: SmHdIFF = 0.685110E+08
 TSMAP: SmHF2F2 = 0.298702E+08
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Number of non-empty rows =         283 =    35.38 % of 2D array
 TSMAP: Total number of coefficients =        1892 =     6.57 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          13
 TSMAP:    Mean number of coefficients per non-empty row =    6.68551    

 TSMAP: Number of non-empty rows =          69 =    34.50 % of 2D array
 TSMAP: Total number of coefficients =         283 =     5.90 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           7
 TSMAP:    Mean number of coefficients per non-empty row =    4.10145    

 TSMAP: Number of non-empty rows =          69 =    34.50 % of 2D array
 TSMAP: Total number of coefficients =         283 =     5.90 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           7
 TSMAP:    Mean number of coefficients per non-empty row =    4.10145    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.680693E-01
 TSMAP: tmax =     0.961643    
 TSMAP: tave =     0.357912    
 TSMAP: tsigma =   0.276736    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.680693E-01
 PSEARCH: Number of peaks in overstore buffer =       84
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.961643     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.961479     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.932651     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.931328     Pos = ( 0.40000, 0.00000, 0.16667)
 PSEARCH:     5 Dens =   0.925400     Pos = ( 0.50000, 0.10000, 0.08333)
 PSEARCH:     6 Dens =   0.923886     Pos = ( 0.50000, 0.10000, 0.16667)
 PSEARCH:     7 Dens =   0.810046     Pos = ( 0.10000, 0.40000, 0.16667)
 PSEARCH:     8 Dens =   0.807474     Pos = ( 0.10000, 0.40000, 0.08333)
 PSEARCH:     9 Dens =   0.804003     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:    10 Dens =   0.788547     Pos = ( 0.40000, 0.00000, 0.25000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    27.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        84
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for        84 independent grid point(s)
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Reflections in asym. unit       26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0043 seconds Direct Translation Search
 TSMAP: tmin =    -0.680694E-01
 TSMAP: tmax =      1.00000    
 TSMAP: tave =     0.356753    
 TSMAP: tsigma =   0.279268    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Used reflections                26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    44185.9    
 TSMAP: SmHdIFF = 0.685110E+08
 TSMAP: SmHF2F2 = 0.298702E+08
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Number of non-empty rows =         283 =    35.38 % of 2D array
 TSMAP: Total number of coefficients =        1892 =     6.57 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          13
 TSMAP:    Mean number of coefficients per non-empty row =    6.68551    

 TSMAP: Number of non-empty rows =          69 =    34.50 % of 2D array
 TSMAP: Total number of coefficients =         283 =     5.90 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           7
 TSMAP:    Mean number of coefficients per non-empty row =    4.10145    

 TSMAP: Number of non-empty rows =          69 =    34.50 % of 2D array
 TSMAP: Total number of coefficients =         283 =     5.90 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           7
 TSMAP:    Mean number of coefficients per non-empty row =    4.10145    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    124
 TSMAP: Selected reflections           124
 TSMAP: Reflections in asym. unit       26
 TSMAP: Sym. equiv. reflections         98
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0003 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0020 seconds Direct Translation Search
 TSMAP: tmin =    -0.680693E-01
 TSMAP: tmax =      1.00000    
 TSMAP: tave =     0.356753    
 TSMAP: tsigma =   0.279268    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.680693E-01
 PSEARCH: Number of peaks in overstore buffer =       84
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =    1.00000     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.999561     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.932651     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.931328     Pos = ( 0.40000, 0.00000, 0.16667)
 PSEARCH:     5 Dens =   0.925400     Pos = ( 0.50000, 0.10000, 0.08333)
 PSEARCH:     6 Dens =   0.923886     Pos = ( 0.50000, 0.10000, 0.16667)
 PSEARCH:     7 Dens =   0.868747     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.866910     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     9 Dens =   0.810046     Pos = ( 0.10000, 0.40000, 0.16667)
 PSEARCH:    10 Dens =   0.807474     Pos = ( 0.10000, 0.40000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    28.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group I-4c2 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     5.010000     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       38 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        38 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        38 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        38 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        38 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      210 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       248 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Maps will be stored in P1:
   A=     0,...,     9  B=     0,...,     9  C=     0,...,    11
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group I-4c2 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  16
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     2  0  1   4
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(Y,-X,-Z)
 | SYMMetry=(-X,-Y,Z)
 | SYMMetry=(-Y,X,-Z)
 | SYMMetry=(Y,X,-Z+1/2)
 | SYMMetry=(-Y,-X,-Z+1/2)
 | SYMMetry=(-X,Y,Z+1/2)
 | SYMMetry=(X,-Y,Z+1/2)
 | SYMMetry=(X+1/2,Y+1/2,Z+1/2)
 | SYMMetry=(Y+1/2,-X+1/2,-Z+1/2)
 | SYMMetry=(-X+1/2,-Y+1/2,Z+1/2)
 | SYMMetry=(-Y+1/2,X+1/2,-Z+1/2)
 | SYMMetry=(Y+1/2,X+1/2,-Z)
 | SYMMetry=(-Y+1/2,-X+1/2,-Z)
 | SYMMetry=(-X+1/2,Y+1/2,Z)
 | SYMMetry=(X+1/2,-Y+1/2,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        84
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   2  0  1   4
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        30
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        24
 FMAP: Independent grid points =        24
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     248
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        24 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0025 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0365 seconds Direct Translation Search
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Number of non-empty rows =         192 =    24.00 % of 2D array
 TSMAP: Total number of coefficients =         976 =     3.39 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    5.08333    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.749321E-01
 PSEARCH: Number of peaks in overstore buffer =       24
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.886675     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.886675     Pos = ( 0.10000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.809080     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.809080     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     5 Dens =   0.656239     Pos = ( 0.00000, 0.10000, 0.00000)
 PSEARCH:     6 Dens =   0.656239     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:     7 Dens =   0.652217     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.652217     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     9 Dens =   0.555808     Pos = ( 0.10000, 0.10000, 0.08333)
 PSEARCH:    10 Dens =   0.534021     Pos = ( 0.40000, 0.10000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    29.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        24
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        24 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0015 seconds Direct Translation Search
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Number of non-empty rows =         192 =    24.00 % of 2D array
 TSMAP: Total number of coefficients =         976 =     3.39 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    5.08333    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Number of non-empty rows =          57 =    28.50 % of 2D array
 TSMAP: Total number of coefficients =         189 =     3.94 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           5
 TSMAP:    Mean number of coefficients per non-empty row =    3.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.749321E-01
 TSMAP: tmax =     0.886675    
 TSMAP: tave =     0.338072    
 TSMAP: tsigma =   0.272557    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.749321E-01
 PSEARCH: Number of peaks in overstore buffer =       24
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.886675     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.886675     Pos = ( 0.10000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.809080     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.809080     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     5 Dens =   0.656239     Pos = ( 0.00000, 0.10000, 0.00000)
 PSEARCH:     6 Dens =   0.656239     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:     7 Dens =   0.652217     Pos = ( 0.00000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.652217     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     9 Dens =   0.555808     Pos = ( 0.10000, 0.10000, 0.08333)
 PSEARCH:    10 Dens =   0.534021     Pos = ( 0.40000, 0.10000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    30.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1200
 FMAP: Remaining independent grid points =        84
 FMAP: Independent grid points =        84
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for        84 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0010 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0057 seconds Direct Translation Search
 TSMAP: tmin =    -0.680694E-01
 TSMAP: tmax =     0.961643    
 TSMAP: tave =     0.357912    
 TSMAP: tsigma =   0.276736    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    44185.9    
 TSMAP: SmHdIFF = 0.685110E+08
 TSMAP: SmHF2F2 = 0.298702E+08
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.680693E-01
 TSMAP: tmax =     0.961643    
 TSMAP: tave =     0.357912    
 TSMAP: tsigma =   0.276736    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.680693E-01
 PSEARCH: Number of peaks in overstore buffer =       84
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.961643     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     2 Dens =   0.961479     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     3 Dens =   0.932651     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.931328     Pos = ( 0.40000, 0.00000, 0.16667)
 PSEARCH:     5 Dens =   0.925400     Pos = ( 0.50000, 0.10000, 0.08333)
 PSEARCH:     6 Dens =   0.923886     Pos = ( 0.50000, 0.10000, 0.16667)
 PSEARCH:     7 Dens =   0.810046     Pos = ( 0.10000, 0.40000, 0.16667)
 PSEARCH:     8 Dens =   0.807474     Pos = ( 0.10000, 0.40000, 0.08333)
 PSEARCH:     9 Dens =   0.804003     Pos = ( 0.50000, 0.10000, 0.00000)
 PSEARCH:    10 Dens =   0.788547     Pos = ( 0.40000, 0.00000, 0.25000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    31.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  10,  10,  12] and sublattice [  10,  10,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     5  B=     0,...,     5  C=     0,...,     3
 Number of deleted points in ASU=          60
 Number of non-zero lattice points in ASU=          84
 Number of special positions in ASU=          16
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        84
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for        84 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0010 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0066 seconds Direct Translation Search
 TSMAP: tmin =    -0.680694E-01
 TSMAP: tmax =      1.00000    
 TSMAP: tave =     0.356753    
 TSMAP: tsigma =   0.279268    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: SmH =              248
 TSMAP: SmHdI2 =  0.638972E+09
 TSMAP: SmHFF =    44185.9    
 TSMAP: SmHdIFF = 0.685110E+08
 TSMAP: SmHF2F2 = 0.298702E+08
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    4   4   3
 TSMAP: Dimensions of scratch array U =    20(  22)   20(  21)   24(  24)
 TSMAP: Dimensions of scratch array V =    40(  42)   40(  41)   36(  36)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       38
 TSMAP: Sym. equiv. reflections        210
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0021 seconds Direct Translation Search
 TSMAP: tmin =    -0.680693E-01
 TSMAP: tmax =      1.00000    
 TSMAP: tave =     0.356753    
 TSMAP: tsigma =   0.279268    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1200 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.680693E-01
 PSEARCH: Number of peaks in overstore buffer =       84
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =    1.00000     Pos = ( 0.50000, 0.00000, 0.16667)
 PSEARCH:     2 Dens =   0.999561     Pos = ( 0.50000, 0.00000, 0.08333)
 PSEARCH:     3 Dens =   0.932651     Pos = ( 0.40000, 0.00000, 0.08333)
 PSEARCH:     4 Dens =   0.931328     Pos = ( 0.40000, 0.00000, 0.16667)
 PSEARCH:     5 Dens =   0.925400     Pos = ( 0.50000, 0.10000, 0.08333)
 PSEARCH:     6 Dens =   0.923886     Pos = ( 0.50000, 0.10000, 0.16667)
 PSEARCH:     7 Dens =   0.868747     Pos = ( 0.50000, 0.00000, 0.00000)
 PSEARCH:     8 Dens =   0.866910     Pos = ( 0.50000, 0.00000, 0.25000)
 PSEARCH:     9 Dens =   0.810046     Pos = ( 0.10000, 0.40000, 0.16667)
 PSEARCH:    10 Dens =   0.807474     Pos = ( 0.10000, 0.40000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    32.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "P3(1)" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($fcx=fcalc) 
 Assuming literal string "FCALC"
 EVALUATE: symbol $FCX set to "FCALC" (string)
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P3(1) in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma = 120) 
 EVALUATE: symbol $GAMMA set to    120.000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.505000     0.000000
     0.000000     4.338787     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_X set to    27.0000     (real)
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_Y set to    27.0000     (real)
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_Z set to    27.0000     (real)
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       83 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of        83 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        83 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        83 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        83 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      164 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       247 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Maps will be stored in P1:
   A=     0,...,    26  B=     0,...,    26  C=     0,...,    53
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,    18
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P3(1) in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   3
 Number of s.s.Vectors & Moduli =   2
   s.s.Vector  Modulus
     0  0  1   0
     1  2  0   3
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-Y,X-Y,Z+1/3)
 | SYMMetry=(-X+Y,-X,Z+2/3)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,    18
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=       13122
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =     39366
 FMAP: Remaining independent grid points =     13122
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   0  0  1  54
 FMAP:   1  2  0   3
 FMAP:       Total number of grid points =     39366
 FMAP: Remaining independent grid points =        83
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =     39366
 FMAP: Remaining independent grid points =        83
 FMAP: Independent grid points =        83
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     247
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        83 independent grid point(s)
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Reflections in asym. unit       83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0047 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0806 seconds Direct Translation Search
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Used reflections                83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   1
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   54(  54)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     39366 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.663210E-01
 PSEARCH: Number of peaks in overstore buffer =       83
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.755517     Pos = ( 0.48148, 0.00000, 0.00000)
 PSEARCH:     2 Dens =   0.749983     Pos = ( 0.51852, 0.00000, 0.00000)
 PSEARCH:     3 Dens =   0.713958     Pos = ( 0.37037, 0.18519, 0.00000)
 PSEARCH:     4 Dens =   0.663253     Pos = ( 0.51852, 0.03704, 0.00000)
 PSEARCH:     5 Dens =   0.609982     Pos = ( 0.37037, 0.14815, 0.00000)
 PSEARCH:     6 Dens =   0.597496     Pos = ( 0.77778, 0.14815, 0.00000)
 PSEARCH:     7 Dens =   0.558745     Pos = ( 0.55556, 0.03704, 0.00000)
 PSEARCH:     8 Dens =   0.557891     Pos = ( 0.48148, 0.03704, 0.00000)
 PSEARCH:     9 Dens =   0.532689     Pos = ( 0.55556, 0.00000, 0.00000)
 PSEARCH:    10 Dens =   0.523032     Pos = ( 0.44444, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    33.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,    18
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=       13122
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        83
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        83 independent grid point(s)
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Reflections in asym. unit       83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0047 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0805 seconds Direct Translation Search
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Used reflections                83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   1
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   54(  54)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.663211E-01
 TSMAP: tmax =     0.755518    
 TSMAP: tave =     0.288067    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     39366 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.663211E-01
 PSEARCH: Number of peaks in overstore buffer =       83
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.755518     Pos = ( 0.48148, 0.00000, 0.00000)
 PSEARCH:     2 Dens =   0.749984     Pos = ( 0.51852, 0.00000, 0.00000)
 PSEARCH:     3 Dens =   0.713959     Pos = ( 0.37037, 0.18519, 0.00000)
 PSEARCH:     4 Dens =   0.663254     Pos = ( 0.51852, 0.03704, 0.00000)
 PSEARCH:     5 Dens =   0.609983     Pos = ( 0.37037, 0.14815, 0.00000)
 PSEARCH:     6 Dens =   0.597497     Pos = ( 0.77778, 0.14815, 0.00000)
 PSEARCH:     7 Dens =   0.558745     Pos = ( 0.55556, 0.03704, 0.00000)
 PSEARCH:     8 Dens =   0.557891     Pos = ( 0.48148, 0.03704, 0.00000)
 PSEARCH:     9 Dens =   0.532690     Pos = ( 0.55556, 0.00000, 0.00000)
 PSEARCH:    10 Dens =   0.523033     Pos = ( 0.44444, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    34.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,    18
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=       13122
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =     39366
 FMAP: Remaining independent grid points =     13122
 FMAP: Independent grid points =     13122
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for     13122 independent grid point(s)
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Reflections in asym. unit       83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0046 seconds Preparing direct translation search
 TSMAP: CPU-time:     1.1492 seconds Direct Translation Search
 TSMAP: tmin =     0.275567E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Used reflections                83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    9193.99    
 TSMAP: SmHdIFF = 0.128100E+07
 TSMAP: SmHF2F2 =  715562.    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   1
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   54(  54)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.275576E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326156    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     39366 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.781952    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.974615     Pos = ( 0.51852, 0.51852, 0.00000)
 PSEARCH:     2 Dens =   0.970327     Pos = ( 0.51852, 0.51852, 0.01852)
 PSEARCH:     3 Dens =   0.968042     Pos = ( 0.48148, 0.48148, 0.00000)
 PSEARCH:     4 Dens =   0.967232     Pos = ( 0.48148, 0.00000, 0.31481)
 PSEARCH:     5 Dens =   0.967146     Pos = ( 0.51852, 0.00000, 0.31481)
 PSEARCH:     6 Dens =   0.957661     Pos = ( 0.51852, 0.00000, 0.29630)
 PSEARCH:     7 Dens =   0.957585     Pos = ( 0.48148, 0.48148, 0.01852)
 PSEARCH:     8 Dens =   0.952415     Pos = ( 0.51852, 0.51852, 0.03704)
 PSEARCH:     9 Dens =   0.950875     Pos = ( 0.48148, 0.00000, 0.29630)
 PSEARCH:    10 Dens =   0.941761     Pos = ( 0.51852, 0.00000, 0.27778)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    35.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  54] and sublattice [  27,  27,  54]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,    18
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=       13122
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =     13122
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for     13122 independent grid point(s)
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Reflections in asym. unit       83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.4803 seconds Direct Translation Search
 TSMAP: tmin =     0.275567E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Used reflections                83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    9193.99    
 TSMAP: SmHdIFF = 0.128100E+07
 TSMAP: SmHF2F2 =  715562.    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   1
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   54(  54)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Number of non-empty rows =         139 =     9.53 % of 2D array
 TSMAP: Total number of coefficients =        1133 =     1.44 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.15108    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     1.60 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     1.60 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    247
 TSMAP: Selected reflections           247
 TSMAP: Reflections in asym. unit       83
 TSMAP: Sym. equiv. reflections        164
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0058 seconds Direct Translation Search
 TSMAP: tmin =     0.275566E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     39366 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.781951    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.974615     Pos = ( 0.51852, 0.51852, 0.00000)
 PSEARCH:     2 Dens =   0.970326     Pos = ( 0.51852, 0.51852, 0.01852)
 PSEARCH:     3 Dens =   0.968042     Pos = ( 0.48148, 0.48148, 0.00000)
 PSEARCH:     4 Dens =   0.967231     Pos = ( 0.48148, 0.00000, 0.31481)
 PSEARCH:     5 Dens =   0.967145     Pos = ( 0.51852, 0.00000, 0.31481)
 PSEARCH:     6 Dens =   0.957661     Pos = ( 0.51852, 0.00000, 0.29630)
 PSEARCH:     7 Dens =   0.957585     Pos = ( 0.48148, 0.48148, 0.01852)
 PSEARCH:     8 Dens =   0.952414     Pos = ( 0.51852, 0.51852, 0.03704)
 PSEARCH:     9 Dens =   0.950874     Pos = ( 0.48148, 0.00000, 0.29630)
 PSEARCH:    10 Dens =   0.941760     Pos = ( 0.51852, 0.00000, 0.27778)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    36.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P3(1) in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma = 120) 
 EVALUATE: symbol $GAMMA set to    120.000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.505000     0.000000
     0.000000     4.338787     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_X set to    27.0000     (real)
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_Y set to    27.0000     (real)
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SGPARAM.SYMGRID_Z set to    27.0000     (real)
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:      166 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of       166 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       166 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of       166 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       166 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      328 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       494 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Maps will be stored in P1:
   A=     0,...,    26  B=     0,...,    26  C=     0,...,    26
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,     9
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P3(1) in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =   3
 Number of s.s.Vectors & Moduli =   2
   s.s.Vector  Modulus
     0  0  1   0
     1  2  0   3
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(-Y,X-Y,Z+1/3)
 | SYMMetry=(-X+Y,-X,Z+2/3)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,     9
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=        6561
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =     19683
 FMAP: Remaining independent grid points =      6561
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   0  0  1  27
 FMAP:   1  2  0   3
 FMAP:       Total number of grid points =     19683
 FMAP: Remaining independent grid points =        83
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =     19683
 FMAP: Remaining independent grid points =        83
 FMAP: Independent grid points =        83
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     494
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        83 independent grid point(s)
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Reflections in asym. unit      166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0051 seconds Direct Translation Search
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Used reflections               166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   2
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   27(  27)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Number of non-empty rows =          71 =     4.87 % of 2D array
 TSMAP: Total number of coefficients =          71 =     0.09 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =          33 =     9.40 % of 2D array
 TSMAP: Total number of coefficients =          33 =     0.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =          33 =     9.40 % of 2D array
 TSMAP: Total number of coefficients =          33 =     0.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     19683 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.663210E-01
 PSEARCH: Number of peaks in overstore buffer =       83
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.755517     Pos = ( 0.48148, 0.00000, 0.00000)
 PSEARCH:     2 Dens =   0.749983     Pos = ( 0.51852, 0.00000, 0.00000)
 PSEARCH:     3 Dens =   0.713958     Pos = ( 0.37037, 0.18519, 0.00000)
 PSEARCH:     4 Dens =   0.663253     Pos = ( 0.51852, 0.03704, 0.00000)
 PSEARCH:     5 Dens =   0.609982     Pos = ( 0.37037, 0.14815, 0.00000)
 PSEARCH:     6 Dens =   0.597496     Pos = ( 0.77778, 0.14815, 0.00000)
 PSEARCH:     7 Dens =   0.558745     Pos = ( 0.55556, 0.03704, 0.00000)
 PSEARCH:     8 Dens =   0.557891     Pos = ( 0.48148, 0.03704, 0.00000)
 PSEARCH:     9 Dens =   0.532689     Pos = ( 0.55556, 0.00000, 0.00000)
 PSEARCH:    10 Dens =   0.523032     Pos = ( 0.44444, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    37.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,     9
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=        6561
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        83
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        83 independent grid point(s)
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Reflections in asym. unit      166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0051 seconds Direct Translation Search
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Used reflections               166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   2
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   27(  27)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Number of non-empty rows =          71 =     4.87 % of 2D array
 TSMAP: Total number of coefficients =          71 =     0.09 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =          33 =     9.40 % of 2D array
 TSMAP: Total number of coefficients =          33 =     0.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Number of non-empty rows =          33 =     9.40 % of 2D array
 TSMAP: Total number of coefficients =          33 =     0.35 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           1
 TSMAP:    Mean number of coefficients per non-empty row =    1.00000    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.663210E-01
 TSMAP: tmax =     0.755517    
 TSMAP: tave =     0.288066    
 TSMAP: tsigma =   0.153797    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     19683 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.663210E-01
 PSEARCH: Number of peaks in overstore buffer =       83
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.755517     Pos = ( 0.48148, 0.00000, 0.00000)
 PSEARCH:     2 Dens =   0.749983     Pos = ( 0.51852, 0.00000, 0.00000)
 PSEARCH:     3 Dens =   0.713958     Pos = ( 0.37037, 0.18519, 0.00000)
 PSEARCH:     4 Dens =   0.663253     Pos = ( 0.51852, 0.03704, 0.00000)
 PSEARCH:     5 Dens =   0.609982     Pos = ( 0.37037, 0.14815, 0.00000)
 PSEARCH:     6 Dens =   0.597496     Pos = ( 0.77778, 0.14815, 0.00000)
 PSEARCH:     7 Dens =   0.558745     Pos = ( 0.55556, 0.03704, 0.00000)
 PSEARCH:     8 Dens =   0.557891     Pos = ( 0.48148, 0.03704, 0.00000)
 PSEARCH:     9 Dens =   0.532689     Pos = ( 0.55556, 0.00000, 0.00000)
 PSEARCH:    10 Dens =   0.523032     Pos = ( 0.44444, 0.00000, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    38.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,     9
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=        6561
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =     19683
 FMAP: Remaining independent grid points =      6561
 FMAP: Independent grid points =      6561
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      6561 independent grid point(s)
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Reflections in asym. unit      166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.4001 seconds Direct Translation Search
 TSMAP: tmin =     0.295974E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Used reflections               166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    9193.99    
 TSMAP: SmHdIFF = 0.128100E+07
 TSMAP: SmHF2F2 =  715562.    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   2
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   27(  27)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Number of non-empty rows =         139 =     9.53 % of 2D array
 TSMAP: Total number of coefficients =        1133 =     1.44 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.15108    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     3.20 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     3.20 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.295976E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     19683 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.726008    
 PSEARCH: Number of peaks in overstore buffer =      108
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.974615     Pos = ( 0.51852, 0.51852, 0.00000)
 PSEARCH:     2 Dens =   0.968042     Pos = ( 0.48148, 0.48148, 0.00000)
 PSEARCH:     3 Dens =   0.957661     Pos = ( 0.51852, 0.00000, 0.29630)
 PSEARCH:     4 Dens =   0.952414     Pos = ( 0.51852, 0.51852, 0.03704)
 PSEARCH:     5 Dens =   0.950874     Pos = ( 0.48148, 0.00000, 0.29630)
 PSEARCH:     6 Dens =   0.934143     Pos = ( 0.48148, 0.48148, 0.03704)
 PSEARCH:     7 Dens =   0.920218     Pos = ( 0.51852, 0.00000, 0.25926)
 PSEARCH:     8 Dens =   0.916944     Pos = ( 0.48148, 0.51852, 0.00000)
 PSEARCH:     9 Dens =   0.912323     Pos = ( 0.14815, 0.33333, 0.25926)
 PSEARCH:    10 Dens =   0.908509     Pos = ( 0.51852, 0.48148, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    39.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  27,  27,  27] and sublattice [  27,  27,  27]
 Minimum brick that covers asymmetric unit:
   A=     0,...,    27  B=     0,...,    27  C=     0,...,     9
 Number of deleted points in ASU=         729
 Number of non-zero lattice points in ASU=        6561
 Number of special positions in ASU=           0
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =      6561
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for      6561 independent grid point(s)
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Reflections in asym. unit      166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0000 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.4033 seconds Direct Translation Search
 TSMAP: tmin =     0.295974E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Used reflections               166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: SmH =              494
 TSMAP: SmHdI2 =  0.101288E+08
 TSMAP: SmHFF =    9193.99    
 TSMAP: SmHdIFF = 0.128100E+07
 TSMAP: SmHF2F2 =  715562.    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    1   1   1
 TSMAP: vFFTgrid set to    2   2   2
 TSMAP: Dimensions of scratch array U =    27(  30)   27(  27)   27(  27)
 TSMAP: Dimensions of scratch array V =    54(  58)   54(  55)   54(  54)
 TSMAP: Number of non-empty rows =         139 =     9.53 % of 2D array
 TSMAP: Total number of coefficients =        1133 =     1.44 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    8.15108    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     3.20 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Number of non-empty rows =          57 =    16.24 % of 2D array
 TSMAP: Total number of coefficients =         303 =     3.20 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    5.31579    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    494
 TSMAP: Selected reflections           494
 TSMAP: Reflections in asym. unit      166
 TSMAP: Sym. equiv. reflections        328
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0006 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0035 seconds Direct Translation Search
 TSMAP: tmin =     0.295976E-02
 TSMAP: tmax =     0.974615    
 TSMAP: tave =     0.326155    
 TSMAP: tsigma =   0.153899    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of     19683 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.726008    
 PSEARCH: Number of peaks in overstore buffer =      108
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.974615     Pos = ( 0.51852, 0.51852, 0.00000)
 PSEARCH:     2 Dens =   0.968042     Pos = ( 0.48148, 0.48148, 0.00000)
 PSEARCH:     3 Dens =   0.957661     Pos = ( 0.51852, 0.00000, 0.29630)
 PSEARCH:     4 Dens =   0.952414     Pos = ( 0.51852, 0.51852, 0.03704)
 PSEARCH:     5 Dens =   0.950874     Pos = ( 0.48148, 0.00000, 0.29630)
 PSEARCH:     6 Dens =   0.934143     Pos = ( 0.48148, 0.48148, 0.03704)
 PSEARCH:     7 Dens =   0.920218     Pos = ( 0.51852, 0.00000, 0.25926)
 PSEARCH:     8 Dens =   0.916944     Pos = ( 0.48148, 0.51852, 0.00000)
 PSEARCH:     9 Dens =   0.912323     Pos = ( 0.14815, 0.33333, 0.25926)
 PSEARCH:    10 Dens =   0.908509     Pos = ( 0.51852, 0.48148, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    40.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "P6(3)/mcm" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($fcx=fcalc) 
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 Assuming literal string "FCALCX"
 EVALUATE: symbol $FCX set to "FCALCX" (string)
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P6(3)/mcm in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma = 120) 
 EVALUATE: symbol $GAMMA set to    120.000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.505000     0.000000
     0.000000     4.338787     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       31 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        31 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        31 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      169 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       200 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P6(3)/mcm in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  24
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     0  0  1   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(X-Y,X,Z+1/2)
 | SYMMetry=(-Y,X-Y,Z)
 | SYMMetry=(-X,-Y,Z+1/2)
 | SYMMetry=(-X+Y,-X,Z)
 | SYMMetry=(Y,-X+Y,Z+1/2)
 | SYMMetry=(X-Y,-Y,-Z+1/2)
 | SYMMetry=(-X,-X+Y,-Z+1/2)
 | SYMMetry=(Y,X,-Z+1/2)
 | SYMMetry=(-Y,-X,-Z)
 | SYMMetry=(-X+Y,Y,-Z)
 | SYMMetry=(X,X-Y,-Z)
 | SYMMetry=(-X,-Y,-Z)
 | SYMMetry=(-X+Y,-X,-Z+1/2)
 | SYMMetry=(Y,-X+Y,-Z)
 | SYMMetry=(X,Y,-Z+1/2)
 | SYMMetry=(X-Y,X,-Z)
 | SYMMetry=(-Y,X-Y,-Z+1/2)
 | SYMMetry=(-X+Y,Y,Z+1/2)
 | SYMMetry=(X,X-Y,Z+1/2)
 | SYMMetry=(-Y,-X,Z+1/2)
 | SYMMetry=(Y,X,Z)
 | SYMMetry=(X-Y,-Y,Z)
 | SYMMetry=(-X,-X+Y,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       112
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   0  0  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        76
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        76
 FMAP: Independent grid points =        76
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     200
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        76 independent grid point(s)
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0242 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.1297 seconds Direct Translation Search
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.122193    
 TSMAP: tmax =     0.781436    
 TSMAP: tave =     0.402802    
 TSMAP: tsigma =   0.156249    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0125
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.122193    
 PSEARCH: Number of peaks in overstore buffer =       76
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.781436     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     2 Dens =   0.781434     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     3 Dens =   0.721101     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     4 Dens =   0.721101     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     5 Dens =   0.708623     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     6 Dens =   0.708619     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     7 Dens =   0.651666     Pos = ( 0.50000, 0.50000, 0.25000)
 PSEARCH:     8 Dens =   0.651663     Pos = ( 0.50000, 0.50000, 0.00000)
 PSEARCH:     9 Dens =   0.641531     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.641530     Pos = ( 0.00000, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    41.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        76
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        76 independent grid point(s)
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0010 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0055 seconds Direct Translation Search
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.122193    
 TSMAP: tmax =     0.781436    
 TSMAP: tave =     0.402802    
 TSMAP: tsigma =   0.156249    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0125
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.122193    
 PSEARCH: Number of peaks in overstore buffer =       76
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.781436     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     2 Dens =   0.781434     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     3 Dens =   0.721101     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     4 Dens =   0.721101     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     5 Dens =   0.708623     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     6 Dens =   0.708619     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     7 Dens =   0.651666     Pos = ( 0.50000, 0.50000, 0.25000)
 PSEARCH:     8 Dens =   0.651663     Pos = ( 0.50000, 0.50000, 0.00000)
 PSEARCH:     9 Dens =   0.641531     Pos = ( 0.00000, 0.00000, 0.16667)
 PSEARCH:    10 Dens =   0.641530     Pos = ( 0.00000, 0.00000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    42.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       112
 FMAP: Independent grid points =       112
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       112 independent grid point(s)
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0010 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0078 seconds Direct Translation Search
 TSMAP: tmin =     0.760068E-01
 TSMAP: tmax =     0.915436    
 TSMAP: tave =     0.453646    
 TSMAP: tsigma =   0.174269    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    49666.6    
 TSMAP: SmHdIFF = 0.602125E+08
 TSMAP: SmHF2F2 = 0.478928E+08
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.760068E-01
 TSMAP: tmax =     0.915436    
 TSMAP: tave =     0.453646    
 TSMAP: tsigma =   0.174269    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.850242E-01
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.915436     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     2 Dens =   0.914016     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     3 Dens =   0.766863     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.765045     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     5 Dens =   0.728323     Pos = ( 0.50000, 0.41667, 0.08333)
 PSEARCH:     6 Dens =   0.723668     Pos = ( 0.50000, 0.41667, 0.16667)
 PSEARCH:     7 Dens =   0.708845     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     8 Dens =   0.707855     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     9 Dens =   0.706267     Pos = ( 0.66667, 0.33333, 0.16667)
 PSEARCH:    10 Dens =   0.705468     Pos = ( 0.50000, 0.08333, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    43.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       112
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       112 independent grid point(s)
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0010 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0099 seconds Direct Translation Search
 TSMAP: tmin =     0.335093E-01
 TSMAP: tmax =     0.999992    
 TSMAP: tave =     0.451828    
 TSMAP: tsigma =   0.181892    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    49666.6    
 TSMAP: SmHdIFF = 0.602125E+08
 TSMAP: SmHF2F2 = 0.478928E+08
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9     6
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    200
 TSMAP: Selected reflections           200
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        169
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0065 seconds Direct Translation Search
 TSMAP: tmin =     0.335093E-01
 TSMAP: tmax =     0.999992    
 TSMAP: tave =     0.451828    
 TSMAP: tsigma =   0.181892    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.363409E-01
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999992     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     2 Dens =   0.997491     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     3 Dens =   0.808203     Pos = ( 0.66667, 0.33333, 0.16667)
 PSEARCH:     4 Dens =   0.797722     Pos = ( 0.66667, 0.33333, 0.08333)
 PSEARCH:     5 Dens =   0.766863     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     6 Dens =   0.765045     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     7 Dens =   0.728323     Pos = ( 0.50000, 0.41667, 0.08333)
 PSEARCH:     8 Dens =   0.723668     Pos = ( 0.50000, 0.41667, 0.16667)
 PSEARCH:     9 Dens =   0.708845     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.707855     Pos = ( 0.50000, 0.25000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    44.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as false
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P6(3)/mcm in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = 5.47) 
 EVALUATE: symbol $C set to    5.47000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma = 120) 
 EVALUATE: symbol $GAMMA set to    120.000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000    -2.505000     0.000000
     0.000000     4.338787     0.000000
     0.000000     0.000000     5.470000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       31 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for real reciprocal space object.
 Total of        31 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  1 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        31 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      369 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       400 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P6(3)/mcm in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as false
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  24
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     0  0  1   2
 Number of ADDLgenerators =   0
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(X-Y,X,Z+1/2)
 | SYMMetry=(-Y,X-Y,Z)
 | SYMMetry=(-X,-Y,Z+1/2)
 | SYMMetry=(-X+Y,-X,Z)
 | SYMMetry=(Y,-X+Y,Z+1/2)
 | SYMMetry=(X-Y,-Y,-Z+1/2)
 | SYMMetry=(-X,-X+Y,-Z+1/2)
 | SYMMetry=(Y,X,-Z+1/2)
 | SYMMetry=(-Y,-X,-Z)
 | SYMMetry=(-X+Y,Y,-Z)
 | SYMMetry=(X,X-Y,-Z)
 | SYMMetry=(-X,-Y,-Z)
 | SYMMetry=(-X+Y,-X,-Z+1/2)
 | SYMMetry=(Y,-X+Y,-Z)
 | SYMMetry=(X,Y,-Z+1/2)
 | SYMMetry=(X-Y,X,-Z)
 | SYMMetry=(-Y,X-Y,-Z+1/2)
 | SYMMetry=(-X+Y,Y,Z+1/2)
 | SYMMetry=(X,X-Y,Z+1/2)
 | SYMMetry=(-Y,-X,Z+1/2)
 | SYMMetry=(Y,X,Z)
 | SYMMetry=(X-Y,-Y,Z)
 | SYMMetry=(-X,-X+Y,Z)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       112
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   0  0  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        76
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        76
 FMAP: Independent grid points =        76
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     400
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XSFAL: allocating space for complex reciprocal space object.
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        76 independent grid point(s)
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0900 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.2248 seconds Direct Translation Search
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.122292    
 PSEARCH: Number of peaks in overstore buffer =       76
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.789253     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     2 Dens =   0.789253     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     3 Dens =   0.722833     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     4 Dens =   0.722833     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     5 Dens =   0.721139     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     6 Dens =   0.721139     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     7 Dens =   0.652234     Pos = ( 0.50000, 0.50000, 0.00000)
 PSEARCH:     8 Dens =   0.652234     Pos = ( 0.50000, 0.50000, 0.25000)
 PSEARCH:     9 Dens =   0.641944     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:    10 Dens =   0.641944     Pos = ( 0.00000, 0.00000, 0.16667)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    45.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        76
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        76 independent grid point(s)
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0063 seconds Direct Translation Search
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Number of non-empty rows =         345 =    53.24 % of 2D array
 TSMAP: Total number of coefficients =        4333 =    13.93 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    12.5594    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         669 =     9.68 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    8.25926    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         669 =     9.68 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          11
 TSMAP:    Mean number of coefficients per non-empty row =    8.25926    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =     0.122292    
 TSMAP: tmax =     0.789253    
 TSMAP: tave =     0.406347    
 TSMAP: tsigma =   0.157504    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.122292    
 PSEARCH: Number of peaks in overstore buffer =       76
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.789253     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     2 Dens =   0.789253     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     3 Dens =   0.722833     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     4 Dens =   0.722833     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     5 Dens =   0.721139     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     6 Dens =   0.721139     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     7 Dens =   0.652234     Pos = ( 0.50000, 0.50000, 0.00000)
 PSEARCH:     8 Dens =   0.652234     Pos = ( 0.50000, 0.50000, 0.25000)
 PSEARCH:     9 Dens =   0.641944     Pos = ( 0.00000, 0.00000, 0.08333)
 PSEARCH:    10 Dens =   0.641944     Pos = ( 0.00000, 0.00000, 0.16667)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    46.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       112
 FMAP: Independent grid points =       112
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       112 independent grid point(s)
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0094 seconds Direct Translation Search
 TSMAP: tmin =     0.760068E-01
 TSMAP: tmax =     0.915436    
 TSMAP: tave =     0.453646    
 TSMAP: tsigma =   0.174269    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    49666.6    
 TSMAP: SmHdIFF = 0.602125E+08
 TSMAP: SmHF2F2 = 0.478928E+08
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Number of non-empty rows =         345 =    53.24 % of 2D array
 TSMAP: Total number of coefficients =        5541 =    17.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          27
 TSMAP:    Mean number of coefficients per non-empty row =    16.0609    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         747 =    10.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.22222    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         747 =    10.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.22222    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =     0.760068E-01
 TSMAP: tmax =     0.915436    
 TSMAP: tave =     0.453646    
 TSMAP: tsigma =   0.174269    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.850242E-01
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.915436     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     2 Dens =   0.914016     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     3 Dens =   0.766863     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.765045     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     5 Dens =   0.728323     Pos = ( 0.50000, 0.41667, 0.08333)
 PSEARCH:     6 Dens =   0.723668     Pos = ( 0.50000, 0.41667, 0.16667)
 PSEARCH:     7 Dens =   0.708845     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:     8 Dens =   0.707855     Pos = ( 0.50000, 0.25000, 0.08333)
 PSEARCH:     9 Dens =   0.706267     Pos = ( 0.66667, 0.33333, 0.16667)
 PSEARCH:    10 Dens =   0.705468     Pos = ( 0.50000, 0.08333, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    47.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     8  B=     0,...,     6  C=     0,...,     3
 Number of deleted points in ASU=          20
 Number of non-zero lattice points in ASU=         112
 Number of special positions in ASU=          69
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       112
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       112 independent grid point(s)
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0002 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0115 seconds Direct Translation Search
 TSMAP: tmin =     0.335093E-01
 TSMAP: tmax =     0.999992    
 TSMAP: tave =     0.451828    
 TSMAP: tsigma =   0.181892    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALCX
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: SmH =              400
 TSMAP: SmHdI2 =  0.492192E+09
 TSMAP: SmHFF =    49666.6    
 TSMAP: SmHdIFF = 0.602125E+08
 TSMAP: SmHF2F2 = 0.478928E+08
 TSMAP: hfcg =      4     4     5
 TSMAP: nfcg =      9     9    11
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   4
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   48(  48)
 TSMAP: Number of non-empty rows =         345 =    53.24 % of 2D array
 TSMAP: Total number of coefficients =        5541 =    17.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           5
 TSMAP: Maximum number of coefficients per non-empty row =          27
 TSMAP:    Mean number of coefficients per non-empty row =    16.0609    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         747 =    10.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.22222    

 TSMAP: Number of non-empty rows =          81 =    28.12 % of 2D array
 TSMAP: Total number of coefficients =         747 =    10.81 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           3
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.22222    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    400
 TSMAP: Selected reflections           400
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        369
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0036 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0115 seconds Direct Translation Search
 TSMAP: tmin =     0.335093E-01
 TSMAP: tmax =     0.999992    
 TSMAP: tave =     0.451828    
 TSMAP: tsigma =   0.181892    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.363409E-01
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999992     Pos = ( 0.50000, 0.50000, 0.16667)
 PSEARCH:     2 Dens =   0.997491     Pos = ( 0.50000, 0.50000, 0.08333)
 PSEARCH:     3 Dens =   0.808203     Pos = ( 0.66667, 0.33333, 0.16667)
 PSEARCH:     4 Dens =   0.797722     Pos = ( 0.66667, 0.33333, 0.08333)
 PSEARCH:     5 Dens =   0.766863     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     6 Dens =   0.765045     Pos = ( 0.33333, 0.16667, 0.08333)
 PSEARCH:     7 Dens =   0.728323     Pos = ( 0.50000, 0.41667, 0.08333)
 PSEARCH:     8 Dens =   0.723668     Pos = ( 0.50000, 0.41667, 0.16667)
 PSEARCH:     9 Dens =   0.708845     Pos = ( 0.50000, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.707855     Pos = ( 0.50000, 0.25000, 0.08333)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    48.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 FOR LOOP: symbol SG set to "P2(1)3" (string)
 CNSsolve>  if ($fcx=fcalcx) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($fcx=fcalc) 
 Assuming literal string "FCALC"
 EVALUATE: symbol $FCX set to "FCALC" (string)
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "FALSE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P2(1)3 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = $a) 
 EVALUATE: symbol $C set to    5.01000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     5.010000     0.000000
     0.000000     0.000000     5.010000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       31 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of        31 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        31 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        31 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      217 new reflections have been generated.
 XREDUC: some reflection(s) converted to CNS standard asymm. unit.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       248 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P2(1)3 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  12
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     1  1  1   2
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(Z,X,Y)
 | SYMMetry=(Y,Z,X)
 | SYMMetry=(-Y+1/2,-Z,X+1/2)
 | SYMMetry=(Z+1/2,-X+1/2,-Y)
 | SYMMetry=(-Y,Z+1/2,-X+1/2)
 | SYMMetry=(-Z+1/2,-X,Y+1/2)
 | SYMMetry=(-Z,X+1/2,-Y+1/2)
 | SYMMetry=(Y+1/2,-Z+1/2,-X)
 | SYMMetry=(-X+1/2,-Y,Z+1/2)
 | SYMMetry=(X+1/2,-Y+1/2,-Z)
 | SYMMetry=(-X,Y+1/2,-Z+1/2)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       152
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  1  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        82
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        42
 FMAP: Independent grid points =        42
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     248
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        42 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0019 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0490 seconds Direct Translation Search
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Number of non-empty rows =         438 =    67.59 % of 2D array
 TSMAP: Total number of coefficients =        3969 =    17.01 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.06164    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         369 =     5.34 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    3.23684    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         369 =     5.34 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    3.23684    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.123464    
 PSEARCH: Number of peaks in overstore buffer =       42
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.845331     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     2 Dens =   0.641419     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     3 Dens =   0.638977     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.574216     Pos = ( 0.25000, 0.25000, 0.08333)
 PSEARCH:     5 Dens =   0.571274     Pos = ( 0.08333, 0.16667, 0.00000)
 PSEARCH:     6 Dens =   0.520796     Pos = ( 0.08333, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.504741     Pos = ( 0.16667, 0.08333, 0.00000)
 PSEARCH:     8 Dens =   0.473995     Pos = ( 0.08333, 0.41667, 0.00000)
 PSEARCH:     9 Dens =   0.473195     Pos = ( 0.33333, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.470284     Pos = ( 0.50000, 0.08333, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    49.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        42
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        42 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0018 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0490 seconds Direct Translation Search
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Number of non-empty rows =         438 =    67.59 % of 2D array
 TSMAP: Total number of coefficients =        3969 =    17.01 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          17
 TSMAP:    Mean number of coefficients per non-empty row =    9.06164    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         369 =     5.34 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    3.23684    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         369 =     5.34 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =           9
 TSMAP:    Mean number of coefficients per non-empty row =    3.23684    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.123464    
 PSEARCH: Number of peaks in overstore buffer =       42
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.845331     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     2 Dens =   0.641419     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     3 Dens =   0.638977     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.574216     Pos = ( 0.25000, 0.25000, 0.08333)
 PSEARCH:     5 Dens =   0.571274     Pos = ( 0.08333, 0.16667, 0.00000)
 PSEARCH:     6 Dens =   0.520796     Pos = ( 0.08333, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.504741     Pos = ( 0.16667, 0.08333, 0.00000)
 PSEARCH:     8 Dens =   0.473995     Pos = ( 0.08333, 0.41667, 0.00000)
 PSEARCH:     9 Dens =   0.473195     Pos = ( 0.33333, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.470284     Pos = ( 0.50000, 0.08333, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    50.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       152
 FMAP: Independent grid points =       152
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($lessdir=true) 
 EVALUATE: symbol $LESSDIR set to TRUE (logical)
 XRAY>              eval($lessfft=false) 
 EVALUATE: symbol $LESSFFT set to FALSE (logical)
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       152 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0080 seconds Direct Translation Search
 TSMAP: tmin =    -0.175768    
 TSMAP: tmax =     0.999892    
 TSMAP: tave =     0.339569    
 TSMAP: tsigma =   0.191419    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    31519.5    
 TSMAP: SmHdIFF = 0.114085E+08
 TSMAP: SmHF2F2 = 0.826971E+07
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.175767    
 TSMAP: tmax =     0.999893    
 TSMAP: tave =     0.339569    
 TSMAP: tsigma =   0.191419    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.236403    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999893     Pos = ( 0.00000, 0.50000,-0.33333)
 PSEARCH:     2 Dens =   0.715558     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     3 Dens =   0.679860     Pos = ( 0.00000, 0.50000,-0.16667)
 PSEARCH:     4 Dens =   0.675828     Pos = ( 0.41667, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.667471     Pos = ( 0.33333, 0.33333,-0.16667)
 PSEARCH:     6 Dens =   0.632176     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     7 Dens =   0.615023     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     8 Dens =   0.605832     Pos = ( 0.41667, 0.41667,-0.08333)
 PSEARCH:     9 Dens =   0.577466     Pos = ( 0.41667, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.569423     Pos = ( 0.41667, 0.16667, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    51.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       152
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 Assuming literal string "SINGLE"
 EVALUATE: symbol $FPREC set to "SINGLE" (string)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       152 independent grid point(s)
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0008 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0091 seconds Direct Translation Search
 TSMAP: tmin =    -0.175768    
 TSMAP: tmax =     0.999892    
 TSMAP: tave =     0.339268    
 TSMAP: tsigma =   0.192212    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Used reflections                31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    31519.5    
 TSMAP: SmHdIFF = 0.114085E+08
 TSMAP: SmHF2F2 = 0.826971E+07
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     5
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    248
 TSMAP: Selected reflections           248
 TSMAP: Reflections in asym. unit       31
 TSMAP: Sym. equiv. reflections        217
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0019 seconds Direct Translation Search
 TSMAP: tmin =    -0.175756    
 TSMAP: tmax =     0.999787    
 TSMAP: tave =     0.339251    
 TSMAP: tsigma =   0.192204    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0001
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.232929    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999787     Pos = ( 0.00000, 0.50000,-0.33333)
 PSEARCH:     2 Dens =   0.715531     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     3 Dens =   0.679829     Pos = ( 0.00000, 0.50000,-0.16667)
 PSEARCH:     4 Dens =   0.675779     Pos = ( 0.41667, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.667432     Pos = ( 0.33333, 0.33333,-0.16667)
 PSEARCH:     6 Dens =   0.632164     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     7 Dens =   0.615011     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     8 Dens =   0.605795     Pos = ( 0.41667, 0.41667,-0.08333)
 PSEARCH:     9 Dens =   0.577457     Pos = ( 0.41667, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.569406     Pos = ( 0.41667, 0.16667, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    52.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 FOR LOOP: symbol ANOMALOUS set to "TRUE" (string)
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.333333) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0.187   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0.128   ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (q=1.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (b=4.0     ) (name=O1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      reset 
 XRAY: whole xray database erased and reset
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      bins=1 
 XRAY> 
 XRAY>      if ($fcx=fcalc) then 
 NEXTCD: condition evaluated as true
 XRAY>        declare name=fobs  domain=reciprocal type=complex end 
 XDECLARE: Object FOBS has been declared.
 XRAY>      else 
 XRAY>        declare name=fobs  domain=reciprocal type=real    end 
 XRAY>      end if 
 XRAY> 
 XRAY>      declare name=fpart domain=reciprocal type=complex end 
 XDECLARE: Object FPART has been declared.
 XRAY>      declare name=fcalc domain=reciprocal type=complex end 
 XDECLARE: Object FCALC has been declared.
 XRAY> 
 XRAY>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 XRAY>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                        (amplitude(fcalc+fpart))^2 )) 
 XRAY>      method=direct 
 XRAY> 
 XRAY>      evaluate ($lr=10000.) 
 EVALUATE: symbol $LR set to    10000.0     (real)
 XRAY>      evaluate ($hr=1) 
 EVALUATE: symbol $HR set to    1.00000     (real)
 XRAY>      binresolution $lr $hr 
 XRAY>      mapresolution $hr 
 XRAY>      tselection=( $hr <= d <= $lr ) 
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 XRAY>      @@CNS_XRAYLIB:scatter.lib 
 ASSFIL: file scatter.lib opened.
 XRAY>! file libraries/xray/scatter.lib 
 XRAY>! Atomic scattering factors without anomalous contribution 
 XRAY>! Library for CNS 
 XRAY> 
 XRAY>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 XRAY> 
 XRAY>!BEWARE: 
 XRAY>!(1) element Cf (Californium) has to be referred to as Cff 
 XRAY>!(2) element Sm (Samarium) has to be referred to as Smm 
 XRAY>!(3) element Np (Neptunium) has to be referred to as Npp 
 XRAY>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 XRAY>!    to be put in double quotes in selection statements. 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old_sclib=$result) 
 EVALUATE: symbol $MESSAGE_OLD_SCLIB set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old_sclib=$result) 
 EVALUATE: symbol $ECHO_OLD_SCLIB set to TRUE (logical)
 XRAY>set echo=off message=off end 
 XRAY>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 XRAY>! file  libraries/xtal/spacegroup.lib 
 XRAY>! library of symmetry operators for CNS 
 XRAY>! Automatically generated with SgInfo Version 2.00a13 
 XRAY> 
 XRAY>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 XRAY> 
 XRAY>set message ? end 
 MESSage=NORM
 XRAY>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 XRAY>set echo ? end 
 ECHO=TRUE {ON}
 XRAY>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 XRAY>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P2(1)3 in library
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 EVALUATE: symbol $A set to    5.01000     (real)
 CNSsolve>      evaluate ($b = $a) 
 EVALUATE: symbol $B set to    5.01000     (real)
 CNSsolve>      evaluate ($c = $a) 
 EVALUATE: symbol $C set to    5.01000     (real)
 CNSsolve>      evaluate ($alpha =  90) 
 EVALUATE: symbol $ALPHA set to    90.0000     (real)
 CNSsolve>      evaluate ($beta  =  90) 
 EVALUATE: symbol $BETA set to    90.0000     (real)
 CNSsolve>      evaluate ($gamma =  90) 
 EVALUATE: symbol $GAMMA set to    90.0000     (real)
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 ORTHO: transformation matrix =
     5.010000     0.000000     0.000000
     0.000000     5.010000     0.000000
     0.000000     0.000000     5.010000
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* set space-group dependent restrictions for map-grid dimensions 
 XRAY>       *} 
 XRAY>      fft 
 XFFT>        grid=0.5 
 XFFT>        xgridfactor=$sgparam.SymGrid_x 
 XFFT>        ygridfactor=$sgparam.SymGrid_y 
 XFFT>        zgridfactor=$sgparam.SymGrid_z 
 XFFT>      end 
 XRAY> 
 XRAY>      {* generate reflections 
 XRAY>       *} 
 XRAY>      anomalous = $anomalous 
 XRAY>      generate 100000. 1.0 
 XGENER: generating reflections to produce a full set
         for the specified resolution range.
 XGENE2:       45 new reflections have been generated.
 XRAY> 
 XRAY>      {* compute dummy "fobs" 
 XRAY>       *} 
 XRAY>      do (fobs=0) (all) 
 XSFAL: allocating space for complex reciprocal space object.
 Total of        45 structure factor elements were selected.
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        45 structure factor elements were selected.
 PREDict>         atomselection=( all ) 
 SELRPN:      2 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      2 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 Total of        45 structure factor elements were selected.
 XRAY> 
 XRAY>      {* compute dummy fpart 
 XRAY>       *} 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fpart 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of        45 structure factor elements were selected.
 PREDict>         atomselection=( name O1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FPART: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XSFAL: allocating space for complex reciprocal space object.
 XRAY> 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (y=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve>    do (z=0) (name=SI1) 
 SELRPN:      1 atoms have been selected out of      2
 CNSsolve> 
 CNSsolve>    xray 
 XRAY>      {* compute fcalc in P1 
 XRAY>       *} 
 XRAY>      expand 
 XEXPA2:      451 new reflections have been generated.
 XRAY: data expanded and symmetry reset to P1.
 XRAY> 
 XRAY>      predict 
 PREDict>         mode=reciprocal 
 PREDict>         to=fcalc 
 PREDict>         selection=( $hr <= d <= $lr ) 
 Total of       496 structure factor elements were selected.
 PREDict>         atomselection=( name SI1 ) 
 SELRPN:      1 atoms have been selected out of      2
 PREDict>      end 
 FCALC: #scatt.=      1 #anomalous=   0 #special pos.=  0 occupancies=1
 XRAY> 
 XRAY>      {* declare maps for both direct and FFT translation search 
 XRAY>       *} 
 XRAY>      declare name=dtsmap domain=real end 
 XRAY>      declare name=ftsmap domain=real end 
 XRAY>      declare name=fcalcx domain=reciprocal type=complex end 
 XDECLARE: Object FCALCX has been declared.
 XRAY> 
 XRAY>      {* define symmetry for flagmap, translation search and peak search 
 XRAY>       *} 
 XRAY>      fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Maps will be stored in P1:
   A=     0,...,    11  B=     0,...,    11  C=     0,...,    11
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 FMAP>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 ASSFIL: file spacegroup.lib opened.
 FMAP>! file  libraries/xtal/spacegroup.lib 
 FMAP>! library of symmetry operators for CNS 
 FMAP>! Automatically generated with SgInfo Version 2.00a13 
 FMAP> 
 FMAP>module 
 MODULE-DECLARATION>( 
 MODULE-DECLARATION>  &sg=$sg; 
 MODULE-DECLARATION>  &sgparam=$sgparam; 
 MODULE-DECLARATION>) 
 &_2_SG set to $_1_SG 
 &_2_SGPARAM set to $_1_SGPARAM 
 FMAP> 
 FMAP>set message ? end 
 MESSage=NORM
 FMAP>evaluate ($message_old=$result) 
 EVALUATE: symbol $MESSAGE_OLD set to "NORM" (string)
 FMAP>set echo ? end 
 ECHO=TRUE {ON}
 FMAP>evaluate ($echo_old=$result) 
 EVALUATE: symbol $ECHO_OLD set to TRUE (logical)
 FMAP>set echo=off message=off end 
SYMMETRY: found symmetry operators for space group P2(1)3 in library
 FMAP> 
 FMAP>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 NEXTCD: condition evaluated as true
 FMAP>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 NEXTCD: condition evaluated as false
 FMAP>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 NEXTCD: condition evaluated as true
 FMAP>        ? 
 --------------FMAP-parameters--------------------------------------------------
 Number of symmetry operations =  12
 Number of s.s.Vectors & Moduli =   1
   s.s.Vector  Modulus
     1  1  1   2
 Number of ADDLgenerators =   1
 USESym=FALSE
 USE_ss=FALSE
 USEAddl=FALSE
 -------------------------------------------------------------------------------
 FMAP>        Symmetry ? 
 --------------FMAP-symmetry----------------------------------------------------
 | SYMMetry=(X,Y,Z)
 | SYMMetry=(Z,X,Y)
 | SYMMetry=(Y,Z,X)
 | SYMMetry=(-Y+1/2,-Z,X+1/2)
 | SYMMetry=(Z+1/2,-X+1/2,-Y)
 | SYMMetry=(-Y,Z+1/2,-X+1/2)
 | SYMMetry=(-Z+1/2,-X,Y+1/2)
 | SYMMetry=(-Z,X+1/2,-Y+1/2)
 | SYMMetry=(Y+1/2,-Z+1/2,-X)
 | SYMMetry=(-X+1/2,-Y,Z+1/2)
 | SYMMetry=(X+1/2,-Y+1/2,-Z)
 | SYMMetry=(-X,Y+1/2,-Z+1/2)
 -------------------------------------------------------------------------------
 FMAP>        AddlGenerators ? 
 --------------FMAP-ADDLgenerators----------------------------------------------
 | SYMMetry=(-X,-Y,-Z)
 -------------------------------------------------------------------------------
 FMAP>      end 
 XRAY>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "FALSE"
 FOR LOOP: symbol PARTIAL set to "FALSE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       152
 FMAP: Removing grid points related by allowed origin shifts
 FMAP: s.s.Vector  Grid-Adjusted-Modulus
 FMAP:   1  1  1   2
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        82
 FMAP: Removing grid points related by operations due to ADDLgenerators
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =        42
 FMAP: Independent grid points =        42
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 XRTSELSET: number of selected reflections     496
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running Direct Translation Search for        42 independent grid point(s)
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Reflections in asym. unit       45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0829 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.1558 seconds Direct Translation Search
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 XMAPAL: allocating space for real space object.
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Used reflections                45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.123438    
 TSMAP: tmax =     0.845202    
 TSMAP: tave =     0.341433    
 TSMAP: tsigma =   0.205278    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0001
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.123438    
 PSEARCH: Number of peaks in overstore buffer =       42
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.845202     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     2 Dens =   0.641381     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     3 Dens =   0.638940     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.574129     Pos = ( 0.25000, 0.25000, 0.08333)
 PSEARCH:     5 Dens =   0.571186     Pos = ( 0.08333, 0.16667, 0.00000)
 PSEARCH:     6 Dens =   0.520780     Pos = ( 0.08333, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.504650     Pos = ( 0.16667, 0.08333, 0.00000)
 PSEARCH:     8 Dens =   0.473977     Pos = ( 0.08333, 0.41667, 0.00000)
 PSEARCH:     9 Dens =   0.473177     Pos = ( 0.33333, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.470279     Pos = ( 0.50000, 0.08333, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    53.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as false
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =        42
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    2.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    3.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as false
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: Running Direct Translation Search for        42 independent grid point(s)
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Reflections in asym. unit       45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0832 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.1110 seconds Direct Translation Search
 TSMAP: tmin =    -0.123464    
 TSMAP: tmax =     0.845331    
 TSMAP: tave =     0.341471    
 TSMAP: tsigma =   0.205296    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as false
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=<undefined>
 TO=FTSMAP
 METHod=FFT
 FPREcision=SINGle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Used reflections                45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    0.00000    
 TSMAP: SmHdIFF =  0.00000    
 TSMAP: SmHF2F2 =  0.00000    
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Allocating scratch array V (single precision)
 TSMAP: Allocating scratch array U (single precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: FPARtfrom=<undefined> ==> SPECialpositions=TRUE ignored.
 TSMAP: tmin =    -0.123438    
 TSMAP: tmax =     0.845202    
 TSMAP: tave =     0.341433    
 TSMAP: tsigma =   0.205278    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0001
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =  -0.123438    
 PSEARCH: Number of peaks in overstore buffer =       42
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.845202     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     2 Dens =   0.641381     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     3 Dens =   0.638940     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     4 Dens =   0.574129     Pos = ( 0.25000, 0.25000, 0.08333)
 PSEARCH:     5 Dens =   0.571186     Pos = ( 0.08333, 0.16667, 0.00000)
 PSEARCH:     6 Dens =   0.520780     Pos = ( 0.08333, 0.08333, 0.00000)
 PSEARCH:     7 Dens =   0.504650     Pos = ( 0.16667, 0.08333, 0.00000)
 PSEARCH:     8 Dens =   0.473977     Pos = ( 0.08333, 0.41667, 0.00000)
 PSEARCH:     9 Dens =   0.473177     Pos = ( 0.33333, 0.25000, 0.16667)
 PSEARCH:    10 Dens =   0.470279     Pos = ( 0.50000, 0.08333, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    54.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 Assuming literal string "TRUE"
 FOR LOOP: symbol PARTIAL set to "TRUE" (string)
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "FALSE"
 FOR LOOP: symbol SPECIAL set to "FALSE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: Building FlagMap
 FMAP: Removing grid points related by symmetry operations
 FMAP:       Total number of grid points =      1728
 FMAP: Remaining independent grid points =       152
 FMAP: Independent grid points =       152
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($fprec=single) then 
 NEXTCD: condition evaluated as true
 XRAY>              eval($fprec=double) 
 Assuming literal string "DOUBLE"
 EVALUATE: symbol $FPREC set to "DOUBLE" (string)
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    4.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($lessfft=true) then 
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 XRAY>              eval($lessfft=true) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       152 independent grid point(s)
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Reflections in asym. unit       45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0035 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0149 seconds Direct Translation Search
 TSMAP: tmin =    -0.175768    
 TSMAP: tmax =     0.999892    
 TSMAP: tave =     0.339569    
 TSMAP: tsigma =   0.191419    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=FALSE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Used reflections                45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    31519.5    
 TSMAP: SmHdIFF = 0.114085E+08
 TSMAP: SmHF2F2 = 0.826971E+07
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Allocating scratch array V (double precision)
 TSMAP: Allocating scratch array U (double precision)
 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: tmin =    -0.175767    
 TSMAP: tmax =     0.999893    
 TSMAP: tave =     0.339569    
 TSMAP: tsigma =   0.191419    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.236403    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999893     Pos = ( 0.00000, 0.50000,-0.33333)
 PSEARCH:     2 Dens =   0.715558     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     3 Dens =   0.679860     Pos = ( 0.00000, 0.50000,-0.16667)
 PSEARCH:     4 Dens =   0.675828     Pos = ( 0.41667, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.667471     Pos = ( 0.33333, 0.33333,-0.16667)
 PSEARCH:     6 Dens =   0.632176     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     7 Dens =   0.615023     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     8 Dens =   0.605832     Pos = ( 0.41667, 0.41667,-0.08333)
 PSEARCH:     9 Dens =   0.577466     Pos = ( 0.41667, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.569423     Pos = ( 0.41667, 0.16667, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    55.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 Assuming literal string "TRUE"
 FOR LOOP: symbol SPECIAL set to "TRUE" (string)
 CNSsolve>        xray 
 XRAY>          {* Build flagmap 
 XRAY>           *} 
 XRAY>          fmap 
 XMAPASU: using grid [  12,  12,  12] and sublattice [  12,  12,  12]
 Minimum brick that covers asymmetric unit:
   A=     0,...,     6  B=     0,...,     6  C=    -6,...,     6
 Number of deleted points in ASU=          79
 Number of non-zero lattice points in ASU=         152
 Number of special positions in ASU=          12
 FMAP>            UseSym = true 
 FMAP>            if ($partial = true) then 
 NEXTCD: condition evaluated as true
 FMAP>              Use_ss  = false 
 FMAP>              UseAddl = false 
 FMAP>            else 
 FMAP>              Use_ss  = true 
 FMAP>              UseAddl = true 
 FMAP>            end if 
 FMAP>            Action=Build 
 FMAP>          end 
 FMAP: FlagMap still valid.
 FMAP: Independent grid points =       152
 XRAY> 
 XRAY>          {* switch FPREcision and LESSmemory 
 XRAY>           *} 
 XRAY>          eval($ilmod = mod($iloop, 3)) 
 EVALUATE: symbol $ILMOD set to    1.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as false
 XRAY>            if ($fprec=single) then 
 XRAY>              eval($fprec=double) 
 XRAY>            else 
 XRAY>              eval($fprec=single) 
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          eval($ilmod = mod($iloop, 5)) 
 EVALUATE: symbol $ILMOD set to    0.00000     (real)
 XRAY>          if ($ilmod < 0.001) then 
 NEXTCD: condition evaluated as true
 XRAY>            if ($lessfft=true) then 
 NEXTCD: condition evaluated as false
 XRAY>              eval($lessdir=true) 
 XRAY>              eval($lessfft=false) 
 XRAY>            else 
 XRAY>              eval($lessdir=false) 
 EVALUATE: symbol $LESSDIR set to FALSE (logical)
 XRAY>              eval($lessfft=true) 
 EVALUATE: symbol $LESSFFT set to TRUE (logical)
 XRAY>            end if 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* direct translation search 
 XRAY>           *} 
 XRAY>          if ($partial=true) then 
 NEXTCD: condition evaluated as true
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 MONItor-expression>                                              (amplitude($$fcx+fpart))^2 )) 
 XRAY>          else 
 XRAY>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 XRAY>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 XRAY>                                              (amplitude($$fcx))^2 )) 
 XRAY>          end if 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=dtsmap 
 TSMAP>            Method=Direct 
 TSMAP>            LESSmemory=$lessdir 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=DTSMAP
 METHod=DIREct
 FPREcision=DOUBle
 LESSmemory=FALSE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running Direct Translation Search for       152 independent grid point(s)
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Reflections in asym. unit       45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0001 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0127 seconds Direct Translation Search
 TSMAP: tmin =    -0.175768    
 TSMAP: tmax =     0.999892    
 TSMAP: tave =     0.339268    
 TSMAP: tsigma =   0.192212    
 XRAY> 
 XRAY>          {* FFT translation search 
 XRAY>           *} 
 XRAY>          search tsmap 
 TSMAP>            FobsFrom=fobs 
 TSMAP>            P1FcalcFrom=fcalc 
 TSMAP>            TrFcalcFrom=$fcx 
 TSMAP>            if ($partial = true) then FpartFrom=fpart end if 
 NEXTCD: condition evaluated as true
 TSMAP>            SpecialPositions = $special 
 TSMAP>            To=ftsmap 
 TSMAP>            Method=FFT 
 TSMAP>            FPREcision=$fprec 
 TSMAP>            LESSmemory=$lessfft 
 TSMAP>            ? 
 -----------tsmap-parameters----------------------------------------------------
 RESEt=FALSE
 FOBSfrom=FOBS
 P1FCalcfrom=FCALC
 TRFCalc=FCALC
 FPARtfrom=FPART
 TO=FTSMAP
 METHod=FFT
 FPREcision=DOUBle
 LESSmemory=TRUE
 SPECialpositions=TRUE
 VERBose=TRUE
 -------------------------------------------------------------------------------
 TSMAP>          end 
 TSMAP: Running FFT Translation Search
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Used reflections                45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: SmH =              496
 TSMAP: SmHdI2 =  0.116565E+09
 TSMAP: SmHFF =    31519.5    
 TSMAP: SmHdIFF = 0.114085E+08
 TSMAP: SmHF2F2 = 0.826971E+07
 TSMAP: hfcg =      4     4     4
 TSMAP: nfcg =      9     9     9
 TSMAP: uFFTgrid set to    2   2   2
 TSMAP: vFFTgrid set to    3   3   3
 TSMAP: Dimensions of scratch array U =    24(  26)   24(  25)   24(  24)
 TSMAP: Dimensions of scratch array V =    36(  38)   36(  37)   36(  36)
 TSMAP: Number of non-empty rows =         438 =    67.59 % of 2D array
 TSMAP: Total number of coefficients =        5739 =    24.60 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          27
 TSMAP:    Mean number of coefficients per non-empty row =    13.1027    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         553 =     8.00 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          13
 TSMAP:    Mean number of coefficients per non-empty row =    4.85088    

 TSMAP: Number of non-empty rows =         114 =    39.58 % of 2D array
 TSMAP: Total number of coefficients =         553 =     8.00 % of 3D array
 TSMAP: Minimum number of coefficients per non-empty row =           1
 TSMAP: Maximum number of coefficients per non-empty row =          13
 TSMAP:    Mean number of coefficients per non-empty row =    4.85088    

 TSMAP: Correlation of dependent and independent grid points =  1.00000
 TSMAP: Running Direct Translation Search for special positions
 TSMAP: Total number of reflections    496
 TSMAP: Selected reflections           496
 TSMAP: Reflections in asym. unit       45
 TSMAP: Sym. equiv. reflections        451
 TSMAP: Preparing direct translation search...
 TSMAP: CPU-time:     0.0035 seconds Preparing direct translation search
 TSMAP: CPU-time:     0.0058 seconds Direct Translation Search
 TSMAP: tmin =    -0.175767    
 TSMAP: tmax =     0.999893    
 TSMAP: tave =     0.339268    
 TSMAP: tsigma =   0.192212    
 XRAY> 
 XRAY>          {* make sure the maps generated by the direct and FFT translation 
 XRAY>             searches are equal within floating point precision 
 XRAY>           *} 
 XRAY>          show max (abs(dtsmap-ftsmap)) (all) 
 Maximum of      1728 elements =                 0.0000
 XRAY>          if ($result > 0.02) then 
 NEXTCD: condition evaluated as false
 XRAY>            display == sg = $sg 
 XRAY>            display == anomalous = $anomalous 
 XRAY>            display == partial = $partial 
 XRAY>            display == special = $special 
 XRAY>            display == fprec = $fprec 
 XRAY>            display == lessdir = $lessdir 
 XRAY>            display == lessfft = $lessfft 
 XRAY>            display == fcx = $fcx 
 XRAY>            abort 
 XRAY>          end if 
 XRAY> 
 XRAY>          {* list the 10 non-redundant highest peaks 
 XRAY>           *} 
 XRAY>          psearch 
 PSEARCH>            From=ftsmap 
 PSEARCH>            level = 0 
 PSEARCH>            nList = 10 
 PSEARCH>            Fractional = true 
 PSEARCH>          end 
 PSEARCH: DensCutOff =   0.232958    
 PSEARCH: Number of peaks in overstore buffer =      110
 PSEARCH: Number of peaks listed              =       10
 PSEARCH:                                   (  Fractional Coordinates  )
 PSEARCH:     1 Dens =   0.999893     Pos = ( 0.00000, 0.50000,-0.33333)
 PSEARCH:     2 Dens =   0.715558     Pos = ( 0.50000, 0.16667, 0.00000)
 PSEARCH:     3 Dens =   0.679860     Pos = ( 0.00000, 0.50000,-0.16667)
 PSEARCH:     4 Dens =   0.675828     Pos = ( 0.41667, 0.41667, 0.08333)
 PSEARCH:     5 Dens =   0.667471     Pos = ( 0.33333, 0.33333,-0.16667)
 PSEARCH:     6 Dens =   0.632176     Pos = ( 0.33333, 0.16667, 0.16667)
 PSEARCH:     7 Dens =   0.615023     Pos = ( 0.41667, 0.08333, 0.08333)
 PSEARCH:     8 Dens =   0.605832     Pos = ( 0.41667, 0.41667,-0.08333)
 PSEARCH:     9 Dens =   0.577466     Pos = ( 0.41667, 0.08333, 0.00000)
 PSEARCH:    10 Dens =   0.569423     Pos = ( 0.41667, 0.16667, 0.00000)
 XRAY> 
 XRAY>          eval($iloop = $iloop + 1) 
 EVALUATE: symbol $ILOOP set to    56.0000     (real)
 XRAY>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve>for $sg in ("P1" "C2/c" "Fddd" "I-4c2" "P3(1)" "P6(3)/mcm" "P2(1)3") loop sg 
 CNSsolve>  if ($fcx=fcalcx) then 
 CNSsolve>    eval($fcx=fcalc) 
 CNSsolve>  else 
 CNSsolve>    eval($fcx=fcalcx) 
 CNSsolve>  end if 
 CNSsolve>  for $anomalous in (false true) loop anomalous 
 CNSsolve>    do (x=0.499   ) (name=SI1) 
 CNSsolve>    do (y=0.000   ) (name=SI1) 
 CNSsolve>    do (z=0.333333) (name=SI1) 
 CNSsolve>    do (q=1.0     ) (name=SI1) 
 CNSsolve>    do (b=2.0     ) (name=SI1) 
 CNSsolve> 
 CNSsolve>    do (x=0.427   ) (name=O1) 
 CNSsolve>    do (y=0.187   ) (name=O1) 
 CNSsolve>    do (z=0.128   ) (name=O1) 
 CNSsolve>    do (q=1.0     ) (name=O1) 
 CNSsolve>    do (b=4.0     ) (name=O1) 
 CNSsolve> 
 CNSsolve>    {* reset all xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      reset 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define some general xray settings 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      bins=1 
 CNSsolve> 
 CNSsolve>      if ($fcx=fcalc) then 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>      else 
 CNSsolve>        declare name=fobs  domain=reciprocal type=real    end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      declare name=fpart domain=reciprocal type=complex end 
 CNSsolve>      declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      target=(F2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      dtarget=(dF2F2[mult=true](amplitude(fobs),fcalc+fpart)) 
 CNSsolve>      monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                        (amplitude(fcalc+fpart))^2 )) 
 CNSsolve>      method=direct 
 CNSsolve> 
 CNSsolve>      evaluate ($lr=10000.) 
 CNSsolve>      evaluate ($hr=1) 
 CNSsolve>      binresolution $lr $hr 
 CNSsolve>      mapresolution $hr 
 CNSsolve>      tselection=( $hr <= d <= $lr ) 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define scattering factors and symmetry 
 CNSsolve>     *} 
 CNSsolve>    xray 
 CNSsolve>      @@CNS_XRAYLIB:scatter.lib 
 CNSsolve>      @@CNS_XTALLIB:spacegroup.lib (sg=$sg; sgparam = $sgparam ) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* define dummy unit cell dimensions based on space group number 
 CNSsolve>     *} 
 CNSsolve> 
 CNSsolve>    if ($sgparam.sg_number <=   2) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha = 100) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma = 110) 
 CNSsolve>    elseif ($sgparam.sg_number <=  15) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  80) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <=  74) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = 6.25) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 142) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    elseif ($sgparam.sg_number <= 194) then 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = 5.47) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma = 120) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($a = 5.01) 
 CNSsolve>      evaluate ($b = $a) 
 CNSsolve>      evaluate ($c = $a) 
 CNSsolve>      evaluate ($alpha =  90) 
 CNSsolve>      evaluate ($beta  =  90) 
 CNSsolve>      evaluate ($gamma =  90) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      a=$a b=$b c=$c alpha=$alpha beta=$beta gamma=$gamma 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    coordinates orthogonalize end 
 CNSsolve> 
 CNSsolve>    {* Make sure there is a test for an odd number grid points 
 CNSsolve>     *} 
 CNSsolve>    if ($sgparam.SymGrid_x = 3) then eval($sgparam.SymGrid_x=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_y = 3) then eval($sgparam.SymGrid_y=27) end if 
 CNSsolve>    if ($sgparam.SymGrid_z = 3) then eval($sgparam.SymGrid_z=27) end if 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* set space-group dependent restrictions for map-grid dimensions 
 CNSsolve>       *} 
 CNSsolve>      fft 
 CNSsolve>        grid=0.5 
 CNSsolve>        xgridfactor=$sgparam.SymGrid_x 
 CNSsolve>        ygridfactor=$sgparam.SymGrid_y 
 CNSsolve>        zgridfactor=$sgparam.SymGrid_z 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* generate reflections 
 CNSsolve>       *} 
 CNSsolve>      anomalous = $anomalous 
 CNSsolve>      generate 100000. 1.0 
 CNSsolve> 
 CNSsolve>      {* compute dummy "fobs" 
 CNSsolve>       *} 
 CNSsolve>      do (fobs=0) (all) 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( all ) 
 CNSsolve>      end 
 CNSsolve>      do (fobs=amplitude(fcalc)) ($hr <= d <= $lr) 
 CNSsolve> 
 CNSsolve>      {* compute dummy fpart 
 CNSsolve>       *} 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fpart 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name O1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    {* move atom for translation search to origin 
 CNSsolve>     *} 
 CNSsolve>    do (x=0) (name=SI1) 
 CNSsolve>    do (y=0) (name=SI1) 
 CNSsolve>    do (z=0) (name=SI1) 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>      {* compute fcalc in P1 
 CNSsolve>       *} 
 CNSsolve>      expand 
 CNSsolve> 
 CNSsolve>      predict 
 CNSsolve>         mode=reciprocal 
 CNSsolve>         to=fcalc 
 CNSsolve>         selection=( $hr <= d <= $lr ) 
 CNSsolve>         atomselection=( name SI1 ) 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      {* declare maps for both direct and FFT translation search 
 CNSsolve>       *} 
 CNSsolve>      declare name=dtsmap domain=real end 
 CNSsolve>      declare name=ftsmap domain=real end 
 CNSsolve>      declare name=fcalcx domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>      {* define symmetry for flagmap, translation search and peak search 
 CNSsolve>       *} 
 CNSsolve>      fmap 
 CNSsolve>        @@CNS_XTALLIB:spacegroup.lib (sg=$sg; &sgparam = $sgparam ) 
 CNSsolve>        if ($sgparam.ssVM_1 # "VOID") then ssVM = $sgparam.ssVM_1 end if 
 CNSsolve>        if ($sgparam.ssVM_2 # "VOID") then ssVM = $sgparam.ssVM_2 end if 
 CNSsolve>        if ($sgparam.ssVM_3 # "VOID") then ssVM = $sgparam.ssVM_3 end if 
 CNSsolve>        if ($sgparam.GenK2L # "VOID") then Addl = $sgparam.GenK2L end if 
 CNSsolve>        ? 
 CNSsolve>        Symmetry ? 
 CNSsolve>        AddlGenerators ? 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    set message=all end 
 CNSsolve> 
 CNSsolve>    for $partial in (false true) loop partial 
 CNSsolve>      for $special in (false true) loop special 
 CNSsolve>        xray 
 CNSsolve>          {* Build flagmap 
 CNSsolve>           *} 
 CNSsolve>          fmap 
 CNSsolve>            UseSym = true 
 CNSsolve>            if ($partial = true) then 
 CNSsolve>              Use_ss  = false 
 CNSsolve>              UseAddl = false 
 CNSsolve>            else 
 CNSsolve>              Use_ss  = true 
 CNSsolve>              UseAddl = true 
 CNSsolve>            end if 
 CNSsolve>            Action=Build 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* switch FPREcision and LESSmemory 
 CNSsolve>           *} 
 CNSsolve>          eval($ilmod = mod($iloop, 3)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($fprec=single) then 
 CNSsolve>              eval($fprec=double) 
 CNSsolve>            else 
 CNSsolve>              eval($fprec=single) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          eval($ilmod = mod($iloop, 5)) 
 CNSsolve>          if ($ilmod < 0.001) then 
 CNSsolve>            if ($lessfft=true) then 
 CNSsolve>              eval($lessdir=true) 
 CNSsolve>              eval($lessfft=false) 
 CNSsolve>            else 
 CNSsolve>              eval($lessdir=false) 
 CNSsolve>              eval($lessfft=true) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* direct translation search 
 CNSsolve>           *} 
 CNSsolve>          if ($partial=true) then 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx+fpart)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx+fpart))^2 )) 
 CNSsolve>          else 
 CNSsolve>            target=(F2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            dtarget=(dF2F2[mult=true](amplitude(fobs),$$fcx)) 
 CNSsolve>            monitor=(corr[overall,mult=true]( (amplitude(fobs))^2, 
 CNSsolve>                                              (amplitude($$fcx))^2 )) 
 CNSsolve>          end if 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=dtsmap 
 CNSsolve>            Method=Direct 
 CNSsolve>            LESSmemory=$lessdir 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* FFT translation search 
 CNSsolve>           *} 
 CNSsolve>          search tsmap 
 CNSsolve>            FobsFrom=fobs 
 CNSsolve>            P1FcalcFrom=fcalc 
 CNSsolve>            TrFcalcFrom=$fcx 
 CNSsolve>            if ($partial = true) then FpartFrom=fpart end if 
 CNSsolve>            SpecialPositions = $special 
 CNSsolve>            To=ftsmap 
 CNSsolve>            Method=FFT 
 CNSsolve>            FPREcision=$fprec 
 CNSsolve>            LESSmemory=$lessfft 
 CNSsolve>            ? 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          {* make sure the maps generated by the direct and FFT translation 
 CNSsolve>             searches are equal within floating point precision 
 CNSsolve>           *} 
 CNSsolve>          show max (abs(dtsmap-ftsmap)) (all) 
 CNSsolve>          if ($result > 0.02) then 
 CNSsolve>            display == sg = $sg 
 CNSsolve>            display == anomalous = $anomalous 
 CNSsolve>            display == partial = $partial 
 CNSsolve>            display == special = $special 
 CNSsolve>            display == fprec = $fprec 
 CNSsolve>            display == lessdir = $lessdir 
 CNSsolve>            display == lessfft = $lessfft 
 CNSsolve>            display == fcx = $fcx 
 CNSsolve>            abort 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          {* list the 10 non-redundant highest peaks 
 CNSsolve>           *} 
 CNSsolve>          psearch 
 CNSsolve>            From=ftsmap 
 CNSsolve>            level = 0 
 CNSsolve>            nList = 10 
 CNSsolve>            Fractional = true 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          eval($iloop = $iloop + 1) 
 CNSsolve>        end 
 CNSsolve>      end loop special {* keep going ... *} 
 CNSsolve>    end loop partial 
 CNSsolve> 
 CNSsolve>    set message=on end 
 CNSsolve> 
 CNSsolve>  end loop anomalous 
 CNSsolve>end loop sg 
 CNSsolve> 
 CNSsolve>stop 
          ============================================================
           Maximum dynamic memory allocation:    13651288 bytes
           Maximum dynamic memory overhead:         14848 bytes
           Program started at: 16:08:11 on 05-Jul-2018
           Program stopped at: 16:08:22 on 05-Jul-2018
           CPU time used:      32.4932 seconds
          ============================================================
